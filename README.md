# 算法导论学习项目

这是一个基于CMake的C++项目，用于学习和实现《算法导论》中的经典算法和数据结构。

## 项目特点

- **模块化设计**: 每个算法/数据结构都有独立的实现和演示程序
- **标准实现**: 严格按照《算法导论》的算法描述和操作规范实现
- **完整测试**: 每个实现都包含详细的演示程序和边界情况测试
- **现代C++**: 使用C++17标准，包含智能指针、模板等现代特性

## 目录结构

```
learn-introduction-to-algorithms/
├── CMakeLists.txt          # CMake配置文件
├── build.sh                # 构建脚本
├── README.md               # 项目说明文档
├── include/                 # 扁平结构头文件目录
│   ├── algorithm_basics.h  # 2章算法基础
│   ├── divide_and_conquer.h # 4章分治策略
│   ├── linear_systems.h    # 28.2节线性方程组求解
│   ├── matrix_inversion.h  # 28.3节矩阵求逆
│   ├── matrix_operations.h # 28.1节矩阵运算基础
│   ├── heap.h              # 6.1节堆数据结构
│   ├── priority_queue.h    # 6.4节优先队列
│   ├── probabilistic_analysis.h # 5章概率分析和随机算法
│   ├── quick_sort.h        # 7章快速排序
│   ├── linear_time_sort.h  # 8章线性时间排序
│   ├── order_statistics.h  # 9章中位数和顺序统计量
│   ├── stack_queue.h       # 10.1节栈和队列
│   ├── linked_list.h       # 10.2节链表
│   ├── rooted_tree.h       # 10.4节有根树
│   ├── hash_table.h        # 11章散列表
│   ├── binary_search_tree.h # 12章二叉搜索树
│   ├── red_black_tree.h    # 13章红黑树
│   ├── order_statistic_tree.h # 14.1章动态顺序统计
│   ├── interval_tree.h     # 14章区间树
│   ├── rod_cutting.h      # 15章钢条切割
│   ├── matrix_chain_multiplication.h # 15.2章矩阵链乘法
│   ├── longest_common_subsequence.h # 15.4章最长公共子序列
│   ├── optimal_binary_search_tree.h # 15.5章最优二叉搜索树
│   ├── greedy_algorithms.h # 16章贪心算法
│   ├── amortized_analysis.h # 17章摊还分析
│   ├── b_tree.h           # 18章B树
│   ├── graph_representation.h # 22.1章图的表示
│   ├── topological_sort.h  # 22.4章拓扑排序
│   ├── minimum_spanning_tree.h # 23章最小生成树
│   ├── shortest_path.h    # 24章单源最短路径
├── all_pairs_shortest_path.h # 25章所有节点对最短路径
├── max_flow.h         # 26章最大流
└── string_matching.h    # 32章字符串匹配
└── source/                 # 章节结构源文件目录
    ├── chapter02/
    │   └── algorithm_basics_demo.cpp # 2章算法基础演示程序
    ├── chapter04/
    │   └── divide_and_conquer_demo.cpp # 4章分治策略演示程序
    ├── chapter28/
    │   └── matrix_operations_demo.cpp # 28章矩阵运算演示程序
    │   └── divide_and_conquer_demo.cpp # 4章分治策略演示程序
    ├── chapter6/
    │   ├── heap_demo.cpp              # 6.1节堆演示程序
    │   └── priority_queue_demo.cpp    # 6.4节优先队列演示程序
    ├── chapter05/
    │   └── probabilistic_analysis_demo.cpp # 5章概率分析和随机算法演示程序
    ├── chapter07/
    │   └── quick_sort_demo.cpp        # 7章快速排序演示程序
    ├── chapter08/
    │   └── linear_time_sort_demo.cpp  # 8章线性时间排序演示程序
    ├── chapter09/
    │   └── order_statistics_demo.cpp  # 9章中位数和顺序统计量演示程序
    ├── chapter10/
    │   ├── stack_queue_demo.cpp       # 10.1节栈和队列演示程序
    │   ├── linked_list_demo.cpp       # 10.2节链表演示程序
    │   └── rooted_tree_demo.cpp       # 10.4节有根树演示程序
    ├── chapter11/
    │   └── hash_table_demo.cpp        # 11章散列表演示程序
    ├── chapter12/
    │   └── binary_search_tree_demo.cpp # 12章二叉搜索树演示程序
    ├── chapter13/
    │   └── red_black_tree_demo.cpp    # 13章红黑树演示程序
    ├── chapter14/
    │   ├── order_statistic_tree_demo.cpp # 14.1章动态顺序统计演示程序
    │   └── interval_tree_demo.cpp     # 14章区间树演示程序
    ├── chapter15/
    │   ├── rod_cutting_demo.cpp       # 15章钢条切割演示程序
    │   ├── matrix_chain_multiplication_demo.cpp # 15.2章矩阵链乘法演示程序
    │   ├── longest_common_subsequence_demo.cpp # 15.4章最长公共子序列演示程序
    │   └── optimal_binary_search_tree_demo.cpp # 15.5章最优二叉搜索树演示程序
    ├── chapter16/
    │   └── greedy_algorithms_demo.cpp # 16章贪心算法演示程序
    ├── chapter17/
    │   └── amortized_analysis_demo.cpp # 17章摊还分析演示程序
    ├── chapter18/
    │   └── b_tree_demo.cpp           # 18章B树演示程序
    ├── chapter22/
    │   ├── graph_representation_demo.cpp # 22.1章图的表示演示程序
    │   └── topological_sort_demo.cpp      # 22.4章拓扑排序演示程序
    ├── chapter23/
    │   └── minimum_spanning_tree_demo.cpp # 23章最小生成树演示程序
    ├── chapter24/
    │   └── shortest_path_demo.cpp       # 24章单源最短路径演示程序
    ├── chapter25/
    │   └── all_pairs_shortest_path_demo.cpp # 25章所有节点对最短路径演示程序
    ├── chapter26/
    │   └── max_flow_demo.cpp             # 26章最大流演示程序
    └── chapter32/
        └── string_matching_demo.cpp      # 32章字符串匹配演示程序
```

## 已实现内容

### 第4章 分治策略

#### 4.1节 最大子数组问题
- **问题描述**: 在数组中找到具有最大和的连续子数组
- **分治策略**: 将数组分为三部分：左半部分、右半部分、跨越中点的部分
- **时间复杂度**: O(n log n)，优于暴力算法的O(n²)
- **算法思想**: 递归求解左右子数组，合并时处理跨越中点的子数组

#### 核心功能
- **分治算法**: 标准的递归分治实现
- **暴力算法**: O(n²)的暴力解法，用于对比验证
- **Kadane算法**: O(n)的线性时间最优算法
- **结果验证**: 自动验证三种算法结果的一致性

#### 算法实现
- **递归分解**: 将问题分解为更小的子问题
- **跨越中点处理**: 线性时间找到跨越中点的最大子数组
- **结果合并**: 比较三种情况的结果选择最优解
- **边界处理**: 正确处理空数组、单元素数组、全负数数组等边界情况

#### 4.2节 矩阵乘法
- **标准算法**: 三层循环的O(n³)矩阵乘法
- **Strassen算法**: 分治策略的矩阵乘法，时间复杂度O(n^log₂7) ≈ O(n^2.81)
- **分治思想**: 将矩阵分为四个子矩阵，递归计算
- **性能优势**: 对于大规模矩阵，Strassen算法比标准算法更高效

#### 核心功能
- **标准矩阵乘法**: 实现传统的三层循环矩阵乘法
- **Strassen算法**: 完整实现Strassen的分治矩阵乘法
- **矩阵操作**: 支持矩阵加法、减法、分割、合并等基本操作
- **结果验证**: 自动验证两种算法结果的一致性

#### 算法实现
- **矩阵分割**: 将n×n矩阵分为四个(n/2)×(n/2)子矩阵
- **递归计算**: 递归计算7个矩阵乘积（Strassen算法的关键）
- **结果合并**: 通过矩阵加减法合并子矩阵结果
- **基础情况**: 处理1×1矩阵的基础情况

#### 4.3-4.5节 递归式求解
- **主定理应用**: 使用主定理求解分治算法的递归式
- **递归式分析**: 分析分治算法的时间复杂度
- **三种情况**: 主定理的三种情况分别对应不同的时间复杂度
- **实际应用**: 分析归并排序、二分查找、矩阵乘法等算法的复杂度

#### 核心功能
- **主定理求解**: 自动求解形如T(n) = aT(n/b) + f(n)的递归式
- **复杂度分析**: 分析常见分治算法的时间复杂度
- **性能预测**: 基于递归式预测算法性能
- **教育价值**: 清晰展示主定理的应用方法

#### 算法实现
- **递归式解析**: 解析递归式的参数a, b, f(n)
- **情况判断**: 根据主定理的三种情况判断时间复杂度
- **结果输出**: 输出递归式的解和复杂度分析

#### 实现特性
- **完整覆盖**: 实现第4章所有核心概念和算法
- **多种解法**: 提供最大子数组问题的三种不同解法
- **性能比较**: 对比分治算法与暴力算法的性能差异
- **教育价值**: 清晰展示分治策略的思想和应用
- **经典示例**: 实现算法导论第4章的经典示例和练习
- **边界处理**: 完善的异常处理和边界情况处理

### 第5章 概率分析和随机算法

#### 5.1节 雇佣问题
- **问题描述**: 面试n个候选人，每次面试后必须立即决定是否雇佣
- **最优策略**: 面试前k个候选人但不雇佣，然后雇佣第一个比前k个都好的候选人
- **概率分析**: 分析不同k值下雇佣到最佳候选人的概率
- **最优k值**: 当k ≈ n/e时，雇佣到最佳候选人的概率最大（约37%）

#### 核心功能
- **基本雇佣问题**: 实现经典的在线雇佣算法
- **在线雇佣问题**: 考虑面试成本和雇佣成本的扩展版本
- **随机化版本**: 使用随机排列来随机化输入顺序
- **概率分析**: 分析不同策略参数下的成功概率

#### 算法实现
- **策略应用**: 实现k-策略的雇佣决策算法
- **成本计算**: 计算面试和雇佣的总成本
- **随机排列**: 使用Fisher-Yates洗牌算法生成随机排列
- **概率模拟**: 通过蒙特卡洛模拟估计概率值

#### 5.2节 随机算法
- **随机化思想**: 通过引入随机性来改进算法性能
- **随机排列生成**: Fisher-Yates洗牌算法的标准实现
- **随机化快速选择**: 期望时间复杂度O(n)的选择算法
- **概率保证**: 随机化算法在期望意义下的性能保证

#### 核心功能
- **随机排列生成**: 生成1到n的均匀随机排列
- **随机化快速选择**: 基于快速排序分区的随机选择算法
- **概率分析工具**: 生日悖论、球与箱子问题等经典概率问题模拟

#### 算法实现
- **Fisher-Yates算法**: 从后向前随机交换元素的洗牌算法
- **随机分区**: 随机选择基准元素的分区操作
- **递归选择**: 基于分区结果的递归选择过程
- **概率模拟**: 大量重复实验的概率估计方法

#### 5.3节 概率分析技术
- **生日悖论**: 分析人群中生日相同的概率
- **球与箱子问题**: 分析随机分配中的负载均衡问题
- **期望值分析**: 计算随机变量的数学期望
- **概率界限**: 使用概率界限分析算法性能

#### 核心功能
- **生日悖论模拟**: 计算不同人数下生日相同的概率
- **负载分析**: 分析球随机投入箱子的最大负载期望
- **最优策略分析**: 分析雇佣问题的最优k值选择
- **性能比较**: 比较随机化算法与确定性算法的性能

#### 实现特性
- **完整覆盖**: 实现第5章所有核心概念和算法
- **概率验证**: 通过大量模拟验证理论概率值
- **性能分析**: 提供算法性能的详细分析
- **教育价值**: 清晰展示概率分析和随机算法的思想
- **经典示例**: 实现算法导论第5章的经典示例和练习

### 第7章 快速排序

#### 7.1节 快速排序的描述
- **算法思想**: 基于分治策略的排序算法，通过分区操作将数组分为两部分
- **核心操作**: 分区操作（PARTITION），选择一个基准元素，将数组重新排列
- **时间复杂度**: 平均O(n log n)，最坏O(n²)，最好O(n log n)
- **空间复杂度**: O(log n) 平均情况，O(n) 最坏情况

#### 核心功能
- **基本快速排序**: 算法导论标准实现，使用最后一个元素作为基准
- **随机化快速排序**: 随机选择基准元素，避免最坏情况
- **三路快速排序**: 处理重复元素，将数组分为三部分
- **尾递归优化**: 减少递归深度，优化空间复杂度

#### 算法实现
- **分区操作**: 将数组分为小于基准、等于基准、大于基准的三部分
- **递归排序**: 对分区后的子数组递归排序
- **随机化选择**: 随机选择基准元素提高平均性能
- **三路分区**: 专门处理大量重复元素的情况

#### 实现特性
- **完整实现**: 包含快速排序的所有变体和优化
- **性能监控**: 提供排序时间统计和性能比较
- **边界处理**: 正确处理空数组、单元素数组等边界情况
- **验证功能**: 自动验证排序结果的正确性
- **经典示例**: 实现算法导论第7.1节的经典示例

#### 7.2节 快速排序的性能
- **最坏情况分析**: 当分区极度不平衡时，时间复杂度为O(n²)
- **最好情况分析**: 每次分区都平衡时，时间复杂度为O(n log n)
- **平均情况分析**: 随机输入下，期望时间复杂度为O(n log n)
- **随机化版本**: 通过随机选择基准避免最坏情况

#### 7.3节 快速排序的随机化版本
- **随机化策略**: 随机选择基准元素，而不是固定选择最后一个元素
- **性能保证**: 随机化版本在任意输入下的期望时间复杂度为O(n log n)
- **实现方法**: 在分区前随机交换基准元素
- **概率分析**: 基于概率论的性能保证

#### 7.4节 快速排序分析
- **递归方程**: 分析快速排序时间复杂度的递归方程
- **主定理应用**: 使用主定理求解递归方程
- **比较次数**: 分析快速排序中的元素比较次数
- **尾递归优化**: 减少递归调用栈的深度

#### 7.5节 三路快速排序
- **重复元素处理**: 当数组中存在大量重复元素时，标准快速排序性能下降
- **三路分区**: 将数组分为小于、等于、大于基准的三部分
- **性能优势**: 对于重复元素较多的数组，性能显著提升
- **实现方法**: 维护三个指针，分别指向小于、等于、大于基准的区域

### 第8章 线性时间排序

#### 8.1节 排序算法的下界
- **比较排序下界**: 任何基于比较的排序算法在最坏情况下都需要Ω(n log n)次比较
- **决策树模型**: 使用决策树分析比较排序算法的下界
- **线性时间排序**: 当输入数据满足特定条件时，可以突破Ω(n log n)的下界

#### 8.2节 计数排序
- **算法思想**: 非比较排序算法，适用于整数范围已知的情况
- **时间复杂度**: O(n + k)，其中k是整数范围
- **空间复杂度**: O(n + k)
- **稳定性**: 计数排序是稳定的排序算法

#### 核心功能
- **基本计数排序**: 适用于元素范围[0, k]的整数排序
- **通用计数排序**: 支持任意范围[min_val, max_val]的整数排序
- **稳定性保证**: 从后往前遍历保证相同元素的相对顺序不变
- **边界处理**: 完善的输入验证和错误处理

#### 算法实现
- **计数数组**: 统计每个元素出现的次数
- **累计计数**: 计算每个元素的最终位置
- **反向填充**: 从后往前遍历保证稳定性
- **范围映射**: 通用版本支持任意整数范围

#### 实现特性
- **完整实现**: 包含基本版本和通用版本
- **稳定性验证**: 自动验证排序的稳定性
- **性能优化**: 达到理论最优时间复杂度
- **经典示例**: 实现算法导论第8.2节的经典示例

#### 8.3节 基数排序
- **算法思想**: 按位排序，从最低有效位到最高有效位
- **时间复杂度**: O(d(n + k))，其中d是最大位数，k是基数（通常为10）
- **稳定性**: 基数排序是稳定的排序算法
- **适用场景**: 适用于多位数整数排序

#### 核心功能
- **按位排序**: 从个位开始逐位排序
- **稳定性保证**: 使用稳定的子排序算法（计数排序）
- **位数计算**: 自动确定最大位数
- **通用性**: 支持任意位数的整数排序

#### 算法实现
- **位数提取**: 提取当前位的数字
- **计数排序**: 对当前位进行稳定的计数排序
- **位遍历**: 从最低位到最高位依次排序
- **性能分析**: 时间复杂度与位数和元素数量相关

#### 实现特性
- **完整实现**: 完整的基数排序算法
- **稳定性保证**: 使用稳定的计数排序作为子程序
- **性能监控**: 提供排序时间和性能统计
- **经典示例**: 实现算法导论第8.3节的经典示例

#### 8.4节 桶排序
- **算法思想**: 将元素分配到多个桶中，对每个桶排序后合并
- **时间复杂度**: 平均O(n)，最坏O(n²)
- **空间复杂度**: O(n)
- **适用场景**: 输入均匀分布在某个区间内

#### 核心功能
- **桶分配**: 将元素均匀分配到n个桶中
- **桶内排序**: 对每个桶使用插入排序
- **桶合并**: 按顺序合并所有桶
- **通用版本**: 支持任意范围的浮点数排序

#### 算法实现
- **桶创建**: 创建n个桶用于元素分配
- **归一化处理**: 将元素映射到[0, 1)范围
- **插入排序**: 对每个桶使用简单的插入排序
- **边界处理**: 处理元素等于最大值的情况

#### 实现特性
- **完整实现**: 包含基本版本和通用版本
- **均匀分布假设**: 基于输入均匀分布的假设
- **性能分析**: 在理想情况下达到线性时间复杂度
- **经典示例**: 实现算法导论第8.4节的经典示例

#### 8.5节 线性时间排序的比较
- **适用条件对比**: 三种线性时间排序算法的适用条件
- **性能对比**: 在不同输入规模下的性能表现
- **稳定性对比**: 三种算法的稳定性分析
- **实际应用**: 各种排序算法在实际场景中的应用

### 第6章 堆排序

#### 6.1节 堆
- **最大堆实现**: 基于数组的最大堆数据结构
- **核心操作**:
  - `max_heapify`: 维护堆性质
  - `build_max_heap`: 构建最大堆
  - 堆排序算法
- **功能特性**:
  - 插入元素（上浮操作）
  - 提取最大值
  - 堆排序
  - 完整的错误处理

#### 6.4节 优先队列
- **基本优先队列**: 基于最大堆的优先队列
- **增强版优先队列**: 支持INCREASE-KEY操作
- **标准操作**:
  - `INSERT(S, x)`: 插入元素
  - `MAXIMUM(S)`: 返回最大元素
  - `EXTRACT-MAX(S)`: 提取并删除最大元素
  - `INCREASE-KEY(S, x, k)`: 增加元素的关键字

### 第11章 散列表

#### 11.1节 直接寻址表
- **基本概念**: 当关键字的全域U比较小时，直接使用关键字作为数组下标
- **时间复杂度**: 所有操作O(1)
- **空间复杂度**: O(|U|)，可能造成空间浪费
- **适用场景**: 关键字全域较小且连续的情况

#### 核心实现
- **数组存储**: 使用数组直接存储元素
- **关键字映射**: 关键字直接作为数组索引
- **空值处理**: 使用nullptr表示空槽位

#### 算法特性
- **操作高效**: 插入、删除、搜索都是常数时间
- **空间浪费**: 当全域很大但实际元素很少时效率低
- **简单直观**: 最容易实现的字典结构

#### 11.2节 散列表
- **基本概念**: 使用散列函数将关键字映射到散列表的槽位
- **冲突解决**: 使用链接法处理散列冲突
- **时间复杂度**: 平均O(1)，最坏O(n)
- **空间复杂度**: O(m+n)，其中m是表大小，n是元素数量

#### 核心实现
- **散列函数**: 将关键字映射到槽位
- **链表处理**: 每个槽位维护一个链表处理冲突
- **负载因子**: 动态监控表的使用情况

#### 算法特性
- **平均高效**: 在合理负载因子下达到常数时间操作
- **动态调整**: 支持动态插入和删除
- **空间高效**: 相比直接寻址表更节省空间

#### 11.3节 散列函数
- **除法散列法**: h(k) = k mod m，简单高效
- **乘法散列法**: h(k) = ⌊m(kA mod 1)⌋，A为常数
- **全域散列法**: 从一组散列函数中随机选择，避免最坏情况
- **字符串散列**: 处理字符串关键字的特殊方法

#### 核心实现
- **模运算**: 除法散列法的核心操作
- **浮点运算**: 乘法散列法使用浮点运算
- **随机化**: 全域散列法引入随机性
- **多项式累积**: 字符串散列使用多项式方法

#### 算法特性
- **分布均匀**: 好的散列函数应该均匀分布关键字
- **计算简单**: 散列函数应该容易计算
- **确定性**: 相同关键字应该产生相同散列值

#### 11.4节 开放寻址法
- **基本概念**: 所有元素都存放在散列表中，不使用链表
- **探查序列**: 当发生冲突时，按照探查序列寻找下一个空槽
- **探查方法**: 线性探查、二次探查、双重散列
- **删除处理**: 使用特殊标记处理删除操作

#### 核心实现
- **线性探查**: h(k,i) = (h'(k) + i) mod m
- **二次探查**: h(k,i) = (h'(k) + c₁i + c₂i²) mod m
- **双重散列**: h(k,i) = (h₁(k) + i·h₂(k)) mod m
- **状态标记**: 使用EMPTY、OCCUPIED、DELETED标记槽位状态

#### 算法特性
- **空间紧凑**: 所有元素存储在表中，无额外指针开销
- **缓存友好**: 连续内存访问有利于缓存性能
- **探查开销**: 冲突时可能需要多次探查

#### 11.5节 完全散列
- **基本概念**: 在静态环境下实现最坏情况O(1)的搜索时间
- **两级散列**: 使用两级散列结构避免冲突
- **平方空间**: 二级表使用元素数量的平方空间
- **静态特性**: 适用于关键字集合固定的情况

#### 核心实现
- **主散列表**: 第一级散列将元素分布到不同槽位
- **二级散列表**: 每个槽位对应一个二级散列表
- **无冲突设计**: 通过选择合适的散列函数避免冲突
- **空间换时间**: 使用更多空间换取最优时间复杂度

#### 算法特性
- **最优搜索**: 最坏情况下O(1)搜索时间
- **静态适用**: 适用于关键字集合不变的情况
- **空间开销**: 需要O(n²)的空间复杂度

#### 实现特性
- **完整覆盖**: 实现所有五种散列技术
- **模板支持**: 支持任意关键字和值类型
- **性能监控**: 提供负载因子和性能统计
- **错误处理**: 完善的边界情况和错误处理
- **算法导论示例**: 完整实现书中的经典示例

### 第9章 中位数和顺序统计量

#### 9.1节 最小值和最大值
- **同时查找算法**: 通过成对比较同时找到最小值和最大值
- **比较次数**: 最多3⌊n/2⌋次比较，优于分别查找的2(n-1)次比较
- **算法思想**: 成对处理元素，每次比较两个元素，然后与当前最小最大值比较

#### 9.2节 期望线性时间的选择算法
- **随机化选择**: 基于快速排序的分区思想
- **时间复杂度**: 期望运行时间O(n)，最坏情况O(n²)
- **算法步骤**:
  1. 随机选择一个基准元素
  2. 将数组分区为小于和大于基准的两部分
  3. 递归在包含目标元素的子数组中继续查找

#### 9.3节 最坏情况线性时间的选择算法
- **确定性选择**: 保证最坏情况线性时间O(n)
- **中位数选择**: 使用中位数的中位数作为基准
- **算法步骤**:
  1. 将数组分成5个一组
  2. 找到每组的中位数
  3. 递归找到中位数的中位数
  4. 使用该中位数作为基准进行分区
  5. 递归在包含目标元素的子数组中继续查找

#### 核心功能
- **中位数查找**: 支持奇数和偶数个元素的中位数计算
- **第i小元素查找**: 两种算法实现（随机化和确定性）
- **边界处理**: 完善的异常处理和边界情况处理
- **算法验证**: 自动验证两种算法结果的一致性

#### 实现特性
- **算法导论标准实现**: 严格遵循第9章的算法描述
- **完整测试覆盖**: 包括算法导论经典示例和边界情况
- **性能保证**: 最坏情况线性时间选择算法
- **代码复用**: 基于第7章快速排序的分区操作
- **模板化设计**: 支持任意可比较数据类型

### 第16章 贪心算法

#### 16.1节 活动选择问题
- **问题描述**: 给定一组活动，每个活动有开始时间和结束时间，选择最大兼容活动子集
- **贪心策略**: 总是选择结束时间最早且与已选活动兼容的活动
- **算法实现**: 递归版本和迭代版本，时间复杂度O(n log n)
- **最优性证明**: 贪心选择性质 + 最优子结构性质

#### 16.2节 贪心算法原理
- **贪心选择性质**: 可以通过局部最优选择构造全局最优解
- **最优子结构性质**: 问题的最优解包含子问题的最优解
- **分数背包问题**: 贪心算法可以得到最优解（与0-1背包问题对比）
- **算法验证**: 验证贪心算法的适用条件和局限性

#### 16.3节 赫夫曼编码
- **前缀码**: 没有任何编码是其他编码的前缀
- **赫夫曼树构建**: 使用优先队列（最小堆）自底向上构建最优前缀码
- **编码效率**: 高频字符使用短编码，低频字符使用长编码
- **压缩率计算**: 自动计算赫夫曼编码的压缩效率

#### 16.4节 拟阵和贪心算法
- **拟阵定义**: 拟阵 M = (S, I) 是一个有序对，其中S是有限集，I是独立集族
- **拟阵性质**: 遗传性（子集保持独立性）和交换性（可以扩展较小独立集）
- **图形拟阵**: 基集为图的边集，独立集为无环边集（森林）
- **贪心最优性**: 在拟阵上的贪心算法总能得到最大权重独立集

#### 16.5节 用拟阵求解任务调度问题
- **问题描述**: 单机任务调度，每个任务有截止时间和惩罚值
- **贪心策略**: 按惩罚值降序排序，为每个任务分配最晚可用时间槽
- **拟阵建模**: 任务调度问题可以建模为拟阵上的优化问题
- **最优性保证**: 基于拟阵理论，贪心算法总能得到最优解

#### 核心功能
- **活动选择**: 最大兼容活动子集选择
- **赫夫曼编码**: 最优前缀码构建和编解码
- **分数背包**: 贪心算法求解分数背包问题
- **拟阵理论**: 图形拟阵和通用拟阵实现
- **任务调度**: 单机任务调度问题求解
- **原理验证**: 贪心选择性质和最优子结构性质验证

#### 实现特性
- **算法导论标准实现**: 严格遵循第16章的算法描述和示例
- **完整测试覆盖**: 包括所有五个贪心算法问题
- **拟阵理论**: 完整的拟阵定义和图形拟阵实现
- **任务调度**: 基于拟阵理论的最优任务调度
- **可视化输出**: 详细的活动时间表、赫夫曼编码表、任务调度结果
- **性能分析**: 时间复杂度分析和压缩率计算
- **对比分析**: 贪心算法与动态规划的对比分析

### 第17章 摊还分析

#### 17.1节 聚合分析
- **二进制计数器**: 实现k位二进制计数器，分析INCREMENT操作的摊还代价
- **翻转次数分析**: 每个位翻转的频率不同，最低位每次翻转，最高位每2^k次翻转
- **总代价分析**: n次INCREMENT操作的总翻转次数为O(n)，平均每次操作O(1)

#### 17.2节 记账方法
- **支持MULTIPOP的栈**: 实现支持MULTIPOP操作的栈数据结构
- **信用分配**: PUSH操作分配2单位摊还代价（1单位实际代价，1单位信用）
- **信用使用**: POP和MULTIPOP操作使用存储的信用，摊还代价为0
- **摊还分析**: 确保任何时刻信用非负，总摊还代价是总实际代价的上界

#### 17.3-17.4节 势能方法和动态表
- **动态表实现**: 支持自动扩张和收缩的动态表数据结构
- **势能函数**: Φ(T) = 2 * num(T) - size(T)，其中num为元素数，size为表容量
- **扩张策略**: 当表满时容量加倍，代价为当前元素数量
- **收缩策略**: 当元素数≤容量/4时容量减半，避免频繁扩张收缩
- **摊还代价**: 每次插入操作的摊还代价为3，每次删除操作的摊还代价为1

#### 核心功能
- **三种分析方法**: 完整实现聚合分析、记账方法、势能方法
- **经典数据结构**: 二进制计数器、支持MULTIPOP的栈、动态表
- **性能监控**: 实时跟踪实际代价、摊还代价、势能变化
- **边界处理**: 完善的异常处理和边界情况处理

#### 实现特性
- **算法导论标准实现**: 严格遵循第17章的算法描述和示例
- **完整测试覆盖**: 包括所有三种摊还分析方法的验证
- **可视化输出**: 详细的表格输出展示操作序列和代价分析
- **理论验证**: 自动验证摊还分析的正确性和一致性
- **教育价值**: 清晰展示摊还分析的思想和应用场景

### 第10章 基本数据结构

#### 10.1节 栈和队列
- **栈实现**: 基于数组的栈数据结构
  - `PUSH(S, x)`: 压入元素
  - `POP(S)`: 弹出元素
  - `STACK-EMPTY(S)`: 检查栈是否为空
- **队列实现**: 基于循环数组的队列
  - `ENQUEUE(Q, x)`: 入队
  - `DEQUEUE(Q)`: 出队
  - `QUEUE-EMPTY(Q)`: 检查队列是否为空
- **扩展实现**:
  - 双端队列（Deque）
  - 用两个栈实现队列（练习10.1-6）

#### 10.2节 链表
- **单向链表**: 支持标准链表操作
  - `LIST-SEARCH(L, k)`: 搜索包含关键字k的元素
  - `LIST-INSERT(L, x)`: 在链表前端插入元素
  - `LIST-DELETE(L, x)`: 删除元素x
- **双向链表**: 支持双向遍历和操作
- **循环链表**: 尾节点指向头节点的循环结构

#### 10.4节 有根树的表示
- **通用有根树**: 支持任意分支的有根树结构
  - 节点包含父指针和子节点向量
  - 深度和高度计算
  - 叶子节点判断
- **遍历算法**:
  - 前序遍历
  - 后序遍历
  - 层序遍历（广度优先）
- **搜索算法**:
  - 广度优先搜索（BFS）
  - 深度优先搜索（DFS）
- **二叉树特例**: 作为有根树的特例实现
  - 左子树和右子树支持
  - 中序遍历、前序遍历、后序遍历

### 第12章 二叉搜索树

#### 12.1节 二叉搜索树
- **标准实现**: 基于指针的二叉搜索树数据结构
- **核心操作**:
  - `INSERT(T, z)`: 插入节点
  - `DELETE(T, z)`: 删除节点
  - `SEARCH(T, k)`: 查找包含关键字k的节点
- **查询操作**:
  - `MINIMUM(x)`: 查找以x为根的子树的最小节点
  - `MAXIMUM(x)`: 查找以x为根的子树的最大节点
  - `SUCCESSOR(x)`: 查找节点x的后继
  - `PREDECESSOR(x)`: 查找节点x的前驱
- **遍历算法**:
  - 中序遍历（按关键字升序）
  - 前序遍历
  - 后序遍历
  - 层序遍历
- **高级特性**:
  - 树高度计算
  - 二叉搜索树性质验证
  - 移植操作（TRANSPLANT）
  - 支持任意可比较数据类型

### 第13章 红黑树

#### 13.1节 红黑树性质
- **红黑树定义**: 满足以下性质的二叉搜索树：
  - 每个节点是红色或黑色
  - 根节点是黑色
  - 每个叶子节点（NIL）是黑色
  - 红色节点的两个子节点都是黑色
  - 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

#### 13.2节 旋转操作
- **左旋操作**: 保持二叉搜索树性质的局部调整
- **右旋操作**: 左旋的对称操作
- **旋转复杂度**: O(1)时间完成

#### 13.3节 插入操作
- **标准插入**: 先按二叉搜索树插入，再修复红黑性质
- **插入修复**: 处理三种情况以维护红黑树性质
  - 情况1：叔叔节点是红色
  - 情况2：叔叔节点是黑色，当前节点是右孩子
  - 情况3：叔叔节点是黑色，当前节点是左孩子

#### 13.4节 删除操作
- **标准删除**: 先按二叉搜索树删除，再修复红黑性质
- **删除修复**: 处理四种情况以维护红黑树性质
  - 情况1：兄弟节点是红色
  - 情况2：兄弟节点是黑色，兄弟的两个孩子都是黑色
  - 情况3：兄弟节点是黑色，兄弟的左孩子是红色，右孩子是黑色
  - 情况4：兄弟节点是黑色，兄弟的右孩子是红色

#### 实现特性
- **NIL节点处理**: 统一的叶子节点表示
- **颜色属性维护**: 严格的颜色约束检查
- **平衡性保证**: 最坏情况下O(log n)的操作复杂度
- **完整验证**: 红黑树五条性质的自动验证

### 第14章 数据结构的扩张

#### 14.1节 动态顺序统计
- **扩展红黑树**: 基于红黑树的顺序统计数据结构扩展
- **节点大小维护**: 每个节点维护以该节点为根的子树的大小
- **核心操作**:
  - `OS-SELECT(i)`: 选择第i小的元素
  - `OS-RANK(x)`: 获取元素x的排名
- **时间复杂度**: 两种操作的时间复杂度均为O(log n)

#### 核心功能
- **动态维护**: 在插入、删除、旋转操作中自动更新size信息
- **一致性保证**: OS-SELECT和OS-RANK操作数学上一致
- **红黑树兼容**: 保持原有红黑树的所有性质和操作
- **模板支持**: 支持任意可比较数据类型

#### 算法实现
- **OS-SELECT算法**: 递归选择第i小的元素
  - 计算当前节点的排名r
  - 如果i = r，返回当前节点
  - 如果i < r，在左子树中递归选择第i小的元素
  - 如果i > r，在右子树中递归选择第i-r小的元素
- **OS-RANK算法**: 计算元素在有序序列中的排名
  - 计算左子树大小得到当前节点的局部排名
  - 向上遍历到根节点，累加路径上的排名贡献
- **size维护**: 在旋转、插入、删除操作中正确更新子树大小

#### 实现特性
- **复用现有实现**: 基于第13章的红黑树实现进行扩展
- **完整验证**: 自动验证顺序统计操作的正确性和一致性
- **边界处理**: 完善的异常处理和边界情况处理
- **性能保证**: 在最坏情况下保持O(log n)的时间复杂度
- **经典示例**: 实现算法导论图14.1的经典示例

#### 14.3节 区间树
- **扩展红黑树**: 基于红黑树的区间数据结构扩展
- **区间表示**: 每个节点存储一个区间 [low, high]
- **附加信息**: 每个节点维护max值（子树中所有区间的最大端点）

#### 核心操作
- **区间插入**: 按low值排序插入，维护红黑性质和max值
- **区间删除**: 删除指定区间，保持树平衡
- **区间搜索**: 查找与给定区间重叠的区间
- **精确搜索**: 查找完全匹配的区间

#### 搜索算法
- **重叠判断**: 两个区间重叠的条件：`low1 ≤ high2` 且 `low2 ≤ high1`
- **高效搜索**: 利用max值进行剪枝，时间复杂度O(log n)
- **搜索策略**:
  - 如果左子树存在且左子树的max ≥ 查询区间的low，搜索左子树
  - 否则搜索右子树

#### 实现特性
- **继承红黑树**: 基于已实现的红黑树进行扩展
- **max值维护**: 在旋转和插入删除操作中自动更新max值
- **区间验证**: 验证区间树性质的正确性
- **模板支持**: 支持任意可比较的区间端点类型

### 第15章 动态规划

#### 15.1节 钢条切割
- **问题描述**: 给定一段长度为n的钢条和一个价格表，求切割钢条方案使得销售收益最大
- **价格表表示**: `p[i]`表示长度为i的钢条的价格
- **最优子结构**: 问题具有最优子结构性质，适合用动态规划求解

#### 算法实现
- **自顶向下递归解法**: 带备忘录的递归方法，避免重复计算
- **自底向上动态规划**: 迭代解法，填充DP表
- **扩展版本**: 返回最大收益和具体的切割方案

#### 核心递推关系
```
r_n = max(p_i + r_{n-i}) for i = 1 to n
```
其中`r_n`表示长度为n的钢条的最大收益

#### 实现特性
- **多种解法**: 提供递归和迭代两种实现方式
- **切割方案重构**: 能够返回具体的切割长度序列
- **边界处理**: 正确处理长度超出价格表的情况
- **验证功能**: 自动验证切割方案的正确性

#### 15.2节 矩阵链乘法
- **问题描述**: 给定n个矩阵的链<A1, A2, ..., An>，矩阵Ai的维度为p_{i-1}×p_i，求完全括号化方案使得标量乘法次数最少
- **最优子结构**: 问题具有最优子结构性质，最优解包含子问题的最优解
- **重叠子问题**: 存在大量重复计算的子问题

#### 核心功能
- **动态规划解法**: 使用二维DP表存储子问题的最优解
- **备忘录版本**: 自顶向下的递归解法，避免重复计算
- **最优括号化**: 返回具体的括号化方案
- **DP表分析**: 提供完整的DP表打印和分析功能

#### 算法实现
- **递推关系**:
  ```
  m[i,j] = min(m[i,k] + m[k+1,j] + p_{i-1} * p_k * p_j) for k = i to j-1
  ```
- **DP表构建**: 按链长度递增的顺序填充DP表
- **分割位置记录**: 记录每个子问题的最优分割位置
- **括号化重构**: 根据分割位置表递归构建括号化方案

#### 实现特性
- **两种版本**: 完整实现动态规划和备忘录两种解法
- **结果验证**: 自动验证两种版本结果的一致性
- **边界处理**: 完善的异常处理和边界情况处理
- **经典示例**: 实现算法导论图15.3的经典示例
- **性能分析**: 时间复杂度O(n³)，空间复杂度O(n²)

#### 15.4节 最长公共子序列
- **问题描述**: 给定两个序列X和Y，求它们的最长公共子序列（LCS）
- **动态规划解法**: 使用二维DP表存储子问题解
- **递推关系**:
  ```
  如果 X[i] = Y[j]: dp[i][j] = dp[i-1][j-1] + 1
  否则: dp[i][j] = max(dp[i-1][j], dp[i][j-1])
  ```

#### 核心功能
- **LCS长度计算**: 计算两个序列的最长公共子序列长度
- **LCS字符串重构**: 返回具体的LCS字符串
- **DP表可视化**: 打印动态规划表和方向表用于调试
- **方向追踪**: 使用方向表记录最优解路径

#### 算法实现
- **自底向上动态规划**: 迭代填充DP表
- **方向表维护**: 记录每个状态的最优选择方向
- **LCS重构算法**: 从方向表反向追踪得到LCS字符串

#### 实现特性
- **完整验证**: 自动验证LCS字符串的正确性
- **边界处理**: 正确处理空序列和单字符序列
- **可视化支持**: 提供DP表和方向表的打印功能
- **多种测试**: 包含经典示例、边界情况和正确性验证

#### 15.5节 最优二叉搜索树
- **问题描述**: 给定一组键值和对应的搜索概率，构建期望搜索成本最小的二叉搜索树
- **动态规划解法**: 使用二维DP表存储子问题的最优解
- **递推关系**:
  ```
  e[i][j] = min(e[i][r-1] + e[r+1][j] + w[i][j]) for r = i to j
  w[i][j] = w[i][j-1] + p[j]
  ```

#### 核心功能
- **最优BST构建**: 基于动态规划算法构建最优二叉搜索树
- **期望成本计算**: 计算最优BST的期望搜索成本
- **DP表可视化**: 打印期望成本表、概率和表和根表
- **树结构展示**: 可视化最优BST的层次结构

#### 算法实现
- **动态规划表**: 维护e[i][j]（期望成本）、w[i][j]（概率和）、root[i][j]（根索引）
- **最优子树构建**: 递归构建最优子树结构
- **概率权重计算**: 考虑所有键值的搜索概率
- **基于现有BST**: 扩展自第12章的二叉搜索树实现

#### 实现特性
- **继承现有BST**: 基于已实现的二叉搜索树进行扩展
- **完整验证**: 自动验证期望成本和树结构的正确性
- **多种概率模式**: 支持均匀概率、集中概率等不同模式
- **对比分析**: 提供与普通BST的性能对比

### 第18章 B树

#### 18.1节 B树的定义
- **B树定义**: 一种平衡的多路搜索树，用于磁盘存储系统
- **B树性质**:
  - 每个节点最多包含2t-1个键值
  - 每个非根节点至少包含t-1个键值
  - 每个节点最多有2t个子节点
  - 所有叶子节点位于同一深度
  - 键值按升序排列

#### 18.2节 B树的基本操作
- **搜索操作**: 从根节点开始，递归搜索合适的子树
- **插入操作**: 先搜索插入位置，必要时分裂节点
- **删除操作**: 处理三种删除情况，必要时合并或借用键值

#### 核心操作
- **节点分裂**: 当节点满时，将中间键值提升到父节点
- **节点合并**: 当节点键值过少时，与兄弟节点合并
- **键值借用**: 从兄弟节点借用键值以保持平衡
- **前驱/后继查找**: 用于内部节点删除操作

#### 算法实现
- **B树节点类**: `BTreeNode` - 包含键值向量和子节点向量
- **B树类**: `BTree` - 管理根节点和最小度数t
- **插入算法**: 递归插入，必要时分裂根节点
- **删除算法**: 处理叶子节点和内部节点的不同情况
- **搜索算法**: 递归搜索，时间复杂度O(log n)

#### 实现特性
- **模板支持**: 支持任意可比较数据类型
- **智能指针**: 使用`std::shared_ptr`管理内存
- **完整验证**: 自动验证B树五条性质
- **调试支持**: 提供树结构打印功能
- **性能优化**: 最小化磁盘I/O操作（模拟）

#### 18.3节 删除操作
- **情况1**: 删除叶子节点中的键值
- **情况2**: 删除内部节点中的键值
  - 情况2a: 前驱子节点有足够键值
  - 情况2b: 后继子节点有足够键值
  - 情况2c: 合并子节点
- **情况3**: 键值不在当前节点中，递归删除

### 第32章 字符串匹配

#### 32.1节 朴素字符串匹配算法
- **算法思想**: 检查文本中所有可能的起始位置，看模式是否匹配
- **时间复杂度**: O((n-m+1)m)，其中n是文本长度，m是模式长度
- **空间复杂度**: O(1)
- **适用场景**: 模式较短，文本不长的情况

#### 核心实现
- **滑动窗口**: 从文本的每个位置开始，检查长度为m的窗口
- **字符比较**: 逐个比较窗口内字符与模式字符
- **匹配记录**: 记录所有匹配的起始位置

#### 算法特性
- **简单直观**: 最容易理解和实现的字符串匹配算法
- **最坏情况**: 当模式频繁出现在文本中时性能较差
- **无预处理**: 不需要对模式进行预处理

#### 32.2节 Rabin-Karp算法
- **算法思想**: 使用哈希技术，将模式哈希与文本子串哈希比较
- **时间复杂度**: 平均O(n+m)，最坏O((n-m+1)m)
- **空间复杂度**: O(1)
- **适用场景**: 需要处理多个模式或模式较长的场景

#### 核心实现
- **滚动哈希**: 使用模运算实现高效的哈希值更新
- **素数选择**: 选择大素数减少哈希冲突
- **哈希验证**: 哈希匹配后进行实际字符比较

#### 算法特性
- **哈希加速**: 利用哈希值快速排除不匹配的位置
- **多模式支持**: 可以同时搜索多个模式
- **伪命中**: 可能存在哈希冲突导致的伪匹配

#### 32.3节 利用有限自动机进行字符串匹配
- **算法思想**: 构建模式对应的有限自动机，在文本上运行自动机
- **时间复杂度**: O(n)，预处理时间O(m|Σ|)
- **空间复杂度**: O(m|Σ|)，其中|Σ|是字母表大小
- **适用场景**: 需要多次使用同一模式的场景

#### 核心实现
- **状态转移表**: 构建模式的状态转移函数
- **后缀函数**: 计算模式前缀的最长真后缀
- **自动机运行**: 在文本字符序列上运行自动机

#### 算法特性
- **线性时间**: 匹配阶段达到最优时间复杂度
- **预处理开销**: 构建自动机需要额外时间和空间
- **字母表依赖**: 性能受字母表大小影响

#### 32.4节 Knuth-Morris-Pratt算法
- **算法思想**: 利用模式的前缀函数避免不必要的比较
- **时间复杂度**: O(n+m)，预处理时间O(m)
- **空间复杂度**: O(m)
- **适用场景**: 通用字符串匹配，特别是模式有重复结构

#### 核心实现
- **前缀函数**: 计算模式每个前缀的最长相等真前缀和真后缀
- **部分匹配表**: 存储前缀函数值用于跳过比较
- **智能回溯**: 利用前缀函数信息避免重复比较

#### 算法特性
- **最优复杂度**: 达到理论最优的时间复杂度
- **空间高效**: 只需要O(m)的额外空间
- **实际高效**: 在实践中通常表现优秀

#### 实现特性
- **完整实现**: 四种经典字符串匹配算法
- **模板支持**: 支持std::string和字符数组
- **性能比较**: 提供算法性能对比功能
- **调试支持**: 显示算法执行过程
- **边界处理**: 完善的错误和边界情况处理

### 第22章 图算法

#### 22.1节 图的表示
- **问题描述**: 图的两种主要表示方法 - 邻接表和邻接矩阵
- **邻接表表示**: 为每个节点维护一个链表，存储其所有邻居
- **邻接矩阵表示**: 使用二维数组表示节点之间的连接关系

#### 核心功能
- **邻接表实现**: 支持无向图和有向图的邻接表表示
- **邻接矩阵实现**: 支持无向图和有向图的邻接矩阵表示
- **图遍历算法**: 广度优先搜索（BFS）和深度优先搜索（DFS）
- **图操作**: 添加节点、添加边、查询邻居、计算度等

#### 算法实现
- **邻接表类**: `AdjacencyListGraph` - 使用链表存储邻居关系
- **邻接矩阵类**: `AdjacencyMatrixGraph` - 使用二维数组存储连接关系
- **图节点和边**: 定义`GraphNode`和`GraphEdge`结构
- **遍历算法**: 基于队列的BFS和基于栈的DFS

#### 实现特性
- **两种表示方法**: 完整实现邻接表和邻接矩阵
- **错误处理**: 完善的异常处理机制
- **性能对比**: 分析两种表示方法的空间和时间复杂度
- **经典示例**: 实现算法导论中的经典图示例
- **完整验证**: 验证两种表示方法的一致性

#### 22.4节 拓扑排序
- **问题描述**: 对有向无环图（DAG）进行线性排序，使得对于每条有向边(u, v)，u在排序中都出现在v之前
- **算法导论方法**: 使用深度优先搜索（DFS）进行拓扑排序
- **替代算法**: 基于入度的Kahn算法

#### 核心功能
- **DFS拓扑排序**: 基于深度优先搜索的拓扑排序算法
- **Kahn拓扑排序**: 基于入度计算的拓扑排序算法
- **环检测**: 自动检测图中是否存在环
- **DAG验证**: 验证图是否为有向无环图

#### 算法实现
- **DFS算法**: 使用DFS遍历图，在节点完成访问时将其加入结果栈
- **Kahn算法**: 基于入度计算，不断移除入度为0的节点
- **环检测机制**: 在DFS过程中检测后向边来判断是否存在环
- **拓扑排序验证**: 验证排序结果是否满足所有边的方向约束

#### 实现特性
- **两种算法**: 完整实现DFS和Kahn两种拓扑排序算法
- **环检测**: 自动检测并报告图中的环
- **经典示例**: 实现算法导论中的穿衣顺序和课程依赖示例
- **完整验证**: 验证拓扑排序结果的正确性
- **性能分析**: 两种算法的时间复杂度均为O(V + E)

### 第23章 最小生成树

#### 23.1节 最小生成树的形成
- **问题描述**: 在连通无向图中找到连接所有节点的最小权重边集合
- **最小生成树性质**: 包含所有节点且总权重最小的树结构
- **应用场景**: 网络设计、电路布线、聚类分析等

#### 23.2节 Kruskal算法和Prim算法
- **Kruskal算法**: 基于边排序和并查集的贪心算法
- **Prim算法**: 基于节点扩展和优先队列的贪心算法
- **算法正确性**: 两种算法都基于贪心选择性质，保证得到最小生成树

#### 核心功能
- **Kruskal算法实现**: 按权重排序边，使用并查集避免环
- **Prim算法实现**: 从起始节点扩展，使用优先队列选择最小权重边
- **MST验证**: 验证生成树是否包含所有节点且无环
- **权重计算**: 计算最小生成树的总权重

#### 算法实现
- **并查集数据结构**: 支持Kruskal算法的集合操作
- **优先队列**: 支持Prim算法的边选择
- **边权重管理**: 完整的权重计算和比较机制
- **图连通性检查**: 确保图是连通的

#### 实现特性
- **两种经典算法**: 完整实现Kruskal和Prim算法
- **并查集优化**: 路径压缩和按秩合并
- **性能分析**: Kruskal O(E log E), Prim O(E log V)
- **经典示例**: 实现算法导论图23.1的经典示例
- **完整验证**: 自动验证最小生成树的正确性
- **错误处理**: 处理有向图、空图等边界情况

### 第24章 单源最短路径

#### 24.1节 Bellman-Ford算法
- **问题描述**: 在一般有向图中（允许负权边）找到从源点到所有其他节点的最短路径
- **算法思想**: 通过|V|-1次松弛操作，逐步逼近最短路径
- **负权环检测**: 额外检查是否存在负权环
- **时间复杂度**: O(VE)，其中V是节点数，E是边数

#### 核心功能
- **松弛操作**: 对每条边进行松弛，更新最短距离估计
- **负权环检测**: 检查是否存在可以无限降低路径权重的环
- **路径重构**: 记录前驱节点，重构最短路径
- **边界处理**: 处理不可达节点和负权环情况

#### 算法实现
- **距离向量**: 存储从源点到每个节点的最短距离估计
- **前驱向量**: 记录最短路径上的前驱节点
- **边遍历**: 对所有边进行|V|-1次松弛操作
- **环检测**: 额外遍历检查是否存在负权环

#### 实现特性
- **通用性**: 支持有向图，允许负权边
- **安全性**: 自动检测负权环并报告
- **完整性**: 返回距离向量、前驱向量和环检测结果
- **经典示例**: 实现算法导论图24.4的经典示例

#### 24.2节 有向无环图中的单源最短路径问题
- **问题描述**: 在有向无环图（DAG）中高效计算单源最短路径
- **算法思想**: 先进行拓扑排序，然后按照拓扑顺序处理节点
- **时间复杂度**: O(V + E)，比Bellman-Ford更高效
- **适用场景**: 图是无环有向图的情况

#### 核心功能
- **拓扑排序**: 对DAG进行线性排序
- **顺序处理**: 按照拓扑顺序松弛出边
- **路径计算**: 计算从源点到所有节点的最短路径
- **DAG验证**: 确保输入图是有向无环图

#### 算法实现
- **拓扑排序算法**: 基于DFS或入度的拓扑排序
- **顺序松弛**: 按照拓扑顺序处理每个节点的出边
- **距离更新**: 在拓扑顺序下保证正确性
- **路径记录**: 记录最短路径的前驱节点

#### 实现特性
- **高效性**: 利用DAG特性达到线性时间复杂度
- **正确性保证**: 拓扑顺序确保松弛操作的顺序正确
- **完整性**: 支持负权边（在DAG中允许）
- **经典示例**: 实现算法导论图24.5的经典示例

#### 24.3节 Dijkstra算法
- **问题描述**: 在非负权有向图中找到从源点到所有其他节点的最短路径
- **算法思想**: 贪心算法，每次选择距离最小的未处理节点
- **数据结构**: 使用优先队列（最小堆）高效选择节点
- **时间复杂度**: O((V + E) log V)，使用二叉堆

#### 核心功能
- **贪心选择**: 每次选择当前距离最小的节点
- **松弛操作**: 更新邻居节点的距离估计
- **优先队列**: 使用最小堆维护未处理节点
- **非负权验证**: 确保图中没有负权边

#### 算法实现
- **距离向量**: 存储从源点到每个节点的最短距离
- **优先队列**: 维护未处理节点的最小距离
- **松弛策略**: 对选定节点的所有出边进行松弛
- **路径记录**: 记录最短路径的前驱节点

#### 实现特性
- **高效性**: 在非负权图中达到最优性能
- **贪心正确性**: 基于非负权假设的贪心选择正确
- **完整性**: 返回所有节点的最短距离和路径
- **经典示例**: 实现算法导论图24.6的经典示例

#### 24.4节 差分约束和最短路径
- **问题描述**: 将差分约束系统转化为最短路径问题求解
- **算法思想**: 构建约束图，使用最短路径算法求解
- **约束转化**: 将x_u - x_v ≤ w转化为边v→u权重w
- **应用场景**: 任务调度、资源分配等约束满足问题

#### 核心功能
- **约束图构建**: 将差分约束转化为有向图
- **虚拟源点**: 添加虚拟源点连接所有节点
- **Bellman-Ford求解**: 使用Bellman-Ford算法求解
- **解的存在性**: 检测约束系统是否有解

#### 算法实现
- **约束解析**: 解析差分约束不等式
- **图构建**: 构建对应的约束图
- **最短路径求解**: 应用Bellman-Ford算法
- **解验证**: 验证解是否满足所有约束

#### 实现特性
- **问题转化**: 将约束满足问题转化为图论问题
- **通用求解**: 支持任意线性不等式约束
- **无解检测**: 自动检测约束系统是否无解
- **实际应用**: 展示最短路径算法的实际应用

#### 24.5节 最短路径性质的证明
- **最优子结构**: 最短路径的任何子路径也是最短路径
- **三角不等式**: 对于任意边(u,v)，有δ(s,v) ≤ δ(s,u) + w(u,v)
- **上界性质**: 距离估计是实际距离的上界
- **收敛性质**: 在无负权环的图中，算法最终收敛

#### 实现特性
- **性质验证**: 自动验证最短路径的各种性质
- **正确性保证**: 基于严格数学证明的算法实现
- **边界情况**: 处理各种边界情况和特殊输入
- **性能分析**: 分析不同算法的时间空间复杂度

## 构建和运行

### 环境要求
- CMake 3.10+
- 支持C++17的编译器（GCC 7+, Clang 5+, MSVC 2017+）

### 构建项目
```bash
# 使用构建脚本（推荐）
./build.sh

# 或者手动构建
mkdir build && cd build
cmake ..
make -j$(nproc)
```

### 运行演示程序
```bash
# 分治策略演示
./build/bin/divide_and_conquer_demo

# 概率分析和随机算法演示
./build/bin/probabilistic_analysis_demo

# 堆演示
./build/bin/heap_demo

# 优先队列演示
./build/bin/priority_queue_demo

# 快速排序演示
./build/bin/quick_sort_demo

# 线性时间排序演示
./build/bin/linear_time_sort_demo

# 栈和队列演示
./build/bin/stack_queue_demo

# 链表演示
./build/bin/linked_list_demo

# 有根树演示
./build/bin/rooted_tree_demo

# 二叉搜索树演示
./build/bin/binary_search_tree_demo

# 红黑树演示
./build/bin/red_black_tree_demo

# 区间树演示
./build/bin/interval_tree_demo

# 钢条切割演示
./build/bin/rod_cutting_demo

# 最长公共子序列演示
./build/bin/longest_common_subsequence_demo

# 最优二叉搜索树演示
./build/bin/optimal_binary_search_tree_demo

# 图的表示演示
./build/bin/graph_representation_demo

# 拓扑排序演示
./build/bin/topological_sort_demo

# 最小生成树演示
./build/bin/minimum_spanning_tree_demo

# 单源最短路径演示
./build/bin/shortest_path_demo

# 所有节点对最短路径演示
./build/bin/all_pairs_shortest_path_demo

# B树演示
./build/bin/b_tree_demo

# 字符串匹配演示
./build/bin/string_matching_demo

# 散列表演示
./build/bin/hash_table_demo

# 顺序统计树演示
./build/bin/order_statistic_tree_demo

# 中位数和顺序统计量演示
./build/bin/order_statistics_demo

# 贪心算法演示
./build/bin/greedy_algorithms_demo

# 摊还分析演示
./build/bin/amortized_analysis_demo

# 矩阵链乘法演示
./build/bin/matrix_chain_multiplication_demo

# 最大流演示
./build/bin/max_flow_demo
```
