# 算法导论学习项目

这是一个基于CMake的C++项目，用于学习和实现《算法导论》中的经典算法和数据结构。

## 项目特点

- **模块化设计**: 每个算法/数据结构都有独立的实现和演示程序
- **标准实现**: 严格按照《算法导论》的算法描述和操作规范实现
- **完整测试**: 每个实现都包含详细的演示程序和边界情况测试
- **现代C++**: 使用C++17标准，包含智能指针、模板等现代特性

## 目录结构

```
learn-introduction-to-algorithms/
├── CMakeLists.txt          # CMake配置文件
├── build.sh                # 构建脚本
├── README.md               # 项目说明文档
├── include/                 # 扁平结构头文件目录
│   ├── heap.h              # 6.1节堆数据结构
│   ├── priority_queue.h    # 6.4节优先队列
│   ├── stack_queue.h       # 10.1节栈和队列
│   ├── linked_list.h       # 10.2节链表
│   ├── rooted_tree.h       # 10.4节有根树
│   ├── hash_table.h        # 11章散列表
│   ├── binary_search_tree.h # 12章二叉搜索树
│   ├── red_black_tree.h    # 13章红黑树
│   ├── interval_tree.h     # 14章区间树
│   ├── rod_cutting.h      # 15章钢条切割
│   ├── longest_common_subsequence.h # 15.4章最长公共子序列
│   ├── optimal_binary_search_tree.h # 15.5章最优二叉搜索树
│   ├── b_tree.h           # 18章B树
│   ├── graph_representation.h # 22.1章图的表示
│   ├── topological_sort.h  # 22.4章拓扑排序
│   ├── minimum_spanning_tree.h # 23章最小生成树
│   ├── shortest_path.h    # 24章单源最短路径
├── all_pairs_shortest_path.h # 25章所有节点对最短路径
├── max_flow.h         # 26章最大流
└── string_matching.h    # 32章字符串匹配
└── source/                 # 章节结构源文件目录
    ├── chapter6/
    │   ├── heap_demo.cpp              # 6.1节堆演示程序
    │   └── priority_queue_demo.cpp    # 6.4节优先队列演示程序
    ├── chapter10/
    │   ├── stack_queue_demo.cpp       # 10.1节栈和队列演示程序
    │   ├── linked_list_demo.cpp       # 10.2节链表演示程序
    │   └── rooted_tree_demo.cpp       # 10.4节有根树演示程序
    ├── chapter11/
    │   └── hash_table_demo.cpp        # 11章散列表演示程序
    ├── chapter12/
    │   └── binary_search_tree_demo.cpp # 12章二叉搜索树演示程序
    ├── chapter13/
    │   └── red_black_tree_demo.cpp    # 13章红黑树演示程序
    ├── chapter14/
    │   └── interval_tree_demo.cpp     # 14章区间树演示程序
    ├── chapter15/
    │   ├── rod_cutting_demo.cpp       # 15章钢条切割演示程序
    │   ├── longest_common_subsequence_demo.cpp # 15.4章最长公共子序列演示程序
    │   └── optimal_binary_search_tree_demo.cpp # 15.5章最优二叉搜索树演示程序
    ├── chapter18/
    │   └── b_tree_demo.cpp           # 18章B树演示程序
    ├── chapter22/
    │   ├── graph_representation_demo.cpp # 22.1章图的表示演示程序
    │   └── topological_sort_demo.cpp      # 22.4章拓扑排序演示程序
    ├── chapter23/
    │   └── minimum_spanning_tree_demo.cpp # 23章最小生成树演示程序
    ├── chapter24/
    │   └── shortest_path_demo.cpp       # 24章单源最短路径演示程序
    ├── chapter25/
    │   └── all_pairs_shortest_path_demo.cpp # 25章所有节点对最短路径演示程序
    ├── chapter26/
    │   └── max_flow_demo.cpp             # 26章最大流演示程序
    └── chapter32/
        └── string_matching_demo.cpp      # 32章字符串匹配演示程序
```

## 已实现内容

### 第6章 堆排序

#### 6.1节 堆
- **最大堆实现**: 基于数组的最大堆数据结构
- **核心操作**:
  - `max_heapify`: 维护堆性质
  - `build_max_heap`: 构建最大堆
  - 堆排序算法
- **功能特性**:
  - 插入元素（上浮操作）
  - 提取最大值
  - 堆排序
  - 完整的错误处理

#### 6.4节 优先队列
- **基本优先队列**: 基于最大堆的优先队列
- **增强版优先队列**: 支持INCREASE-KEY操作
- **标准操作**:
  - `INSERT(S, x)`: 插入元素
  - `MAXIMUM(S)`: 返回最大元素
  - `EXTRACT-MAX(S)`: 提取并删除最大元素
  - `INCREASE-KEY(S, x, k)`: 增加元素的关键字

### 第11章 散列表

#### 11.1节 直接寻址表
- **基本概念**: 当关键字的全域U比较小时，直接使用关键字作为数组下标
- **时间复杂度**: 所有操作O(1)
- **空间复杂度**: O(|U|)，可能造成空间浪费
- **适用场景**: 关键字全域较小且连续的情况

#### 核心实现
- **数组存储**: 使用数组直接存储元素
- **关键字映射**: 关键字直接作为数组索引
- **空值处理**: 使用nullptr表示空槽位

#### 算法特性
- **操作高效**: 插入、删除、搜索都是常数时间
- **空间浪费**: 当全域很大但实际元素很少时效率低
- **简单直观**: 最容易实现的字典结构

#### 11.2节 散列表
- **基本概念**: 使用散列函数将关键字映射到散列表的槽位
- **冲突解决**: 使用链接法处理散列冲突
- **时间复杂度**: 平均O(1)，最坏O(n)
- **空间复杂度**: O(m+n)，其中m是表大小，n是元素数量

#### 核心实现
- **散列函数**: 将关键字映射到槽位
- **链表处理**: 每个槽位维护一个链表处理冲突
- **负载因子**: 动态监控表的使用情况

#### 算法特性
- **平均高效**: 在合理负载因子下达到常数时间操作
- **动态调整**: 支持动态插入和删除
- **空间高效**: 相比直接寻址表更节省空间

#### 11.3节 散列函数
- **除法散列法**: h(k) = k mod m，简单高效
- **乘法散列法**: h(k) = ⌊m(kA mod 1)⌋，A为常数
- **全域散列法**: 从一组散列函数中随机选择，避免最坏情况
- **字符串散列**: 处理字符串关键字的特殊方法

#### 核心实现
- **模运算**: 除法散列法的核心操作
- **浮点运算**: 乘法散列法使用浮点运算
- **随机化**: 全域散列法引入随机性
- **多项式累积**: 字符串散列使用多项式方法

#### 算法特性
- **分布均匀**: 好的散列函数应该均匀分布关键字
- **计算简单**: 散列函数应该容易计算
- **确定性**: 相同关键字应该产生相同散列值

#### 11.4节 开放寻址法
- **基本概念**: 所有元素都存放在散列表中，不使用链表
- **探查序列**: 当发生冲突时，按照探查序列寻找下一个空槽
- **探查方法**: 线性探查、二次探查、双重散列
- **删除处理**: 使用特殊标记处理删除操作

#### 核心实现
- **线性探查**: h(k,i) = (h'(k) + i) mod m
- **二次探查**: h(k,i) = (h'(k) + c₁i + c₂i²) mod m
- **双重散列**: h(k,i) = (h₁(k) + i·h₂(k)) mod m
- **状态标记**: 使用EMPTY、OCCUPIED、DELETED标记槽位状态

#### 算法特性
- **空间紧凑**: 所有元素存储在表中，无额外指针开销
- **缓存友好**: 连续内存访问有利于缓存性能
- **探查开销**: 冲突时可能需要多次探查

#### 11.5节 完全散列
- **基本概念**: 在静态环境下实现最坏情况O(1)的搜索时间
- **两级散列**: 使用两级散列结构避免冲突
- **平方空间**: 二级表使用元素数量的平方空间
- **静态特性**: 适用于关键字集合固定的情况

#### 核心实现
- **主散列表**: 第一级散列将元素分布到不同槽位
- **二级散列表**: 每个槽位对应一个二级散列表
- **无冲突设计**: 通过选择合适的散列函数避免冲突
- **空间换时间**: 使用更多空间换取最优时间复杂度

#### 算法特性
- **最优搜索**: 最坏情况下O(1)搜索时间
- **静态适用**: 适用于关键字集合不变的情况
- **空间开销**: 需要O(n²)的空间复杂度

#### 实现特性
- **完整覆盖**: 实现所有五种散列技术
- **模板支持**: 支持任意关键字和值类型
- **性能监控**: 提供负载因子和性能统计
- **错误处理**: 完善的边界情况和错误处理
- **算法导论示例**: 完整实现书中的经典示例

### 第10章 基本数据结构

#### 10.1节 栈和队列
- **栈实现**: 基于数组的栈数据结构
  - `PUSH(S, x)`: 压入元素
  - `POP(S)`: 弹出元素
  - `STACK-EMPTY(S)`: 检查栈是否为空
- **队列实现**: 基于循环数组的队列
  - `ENQUEUE(Q, x)`: 入队
  - `DEQUEUE(Q)`: 出队
  - `QUEUE-EMPTY(Q)`: 检查队列是否为空
- **扩展实现**:
  - 双端队列（Deque）
  - 用两个栈实现队列（练习10.1-6）

#### 10.2节 链表
- **单向链表**: 支持标准链表操作
  - `LIST-SEARCH(L, k)`: 搜索包含关键字k的元素
  - `LIST-INSERT(L, x)`: 在链表前端插入元素
  - `LIST-DELETE(L, x)`: 删除元素x
- **双向链表**: 支持双向遍历和操作
- **循环链表**: 尾节点指向头节点的循环结构

#### 10.4节 有根树的表示
- **通用有根树**: 支持任意分支的有根树结构
  - 节点包含父指针和子节点向量
  - 深度和高度计算
  - 叶子节点判断
- **遍历算法**:
  - 前序遍历
  - 后序遍历
  - 层序遍历（广度优先）
- **搜索算法**:
  - 广度优先搜索（BFS）
  - 深度优先搜索（DFS）
- **二叉树特例**: 作为有根树的特例实现
  - 左子树和右子树支持
  - 中序遍历、前序遍历、后序遍历

### 第12章 二叉搜索树

#### 12.1节 二叉搜索树
- **标准实现**: 基于指针的二叉搜索树数据结构
- **核心操作**:
  - `INSERT(T, z)`: 插入节点
  - `DELETE(T, z)`: 删除节点
  - `SEARCH(T, k)`: 查找包含关键字k的节点
- **查询操作**:
  - `MINIMUM(x)`: 查找以x为根的子树的最小节点
  - `MAXIMUM(x)`: 查找以x为根的子树的最大节点
  - `SUCCESSOR(x)`: 查找节点x的后继
  - `PREDECESSOR(x)`: 查找节点x的前驱
- **遍历算法**:
  - 中序遍历（按关键字升序）
  - 前序遍历
  - 后序遍历
  - 层序遍历
- **高级特性**:
  - 树高度计算
  - 二叉搜索树性质验证
  - 移植操作（TRANSPLANT）
  - 支持任意可比较数据类型

### 第13章 红黑树

#### 13.1节 红黑树性质
- **红黑树定义**: 满足以下性质的二叉搜索树：
  - 每个节点是红色或黑色
  - 根节点是黑色
  - 每个叶子节点（NIL）是黑色
  - 红色节点的两个子节点都是黑色
  - 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

#### 13.2节 旋转操作
- **左旋操作**: 保持二叉搜索树性质的局部调整
- **右旋操作**: 左旋的对称操作
- **旋转复杂度**: O(1)时间完成

#### 13.3节 插入操作
- **标准插入**: 先按二叉搜索树插入，再修复红黑性质
- **插入修复**: 处理三种情况以维护红黑树性质
  - 情况1：叔叔节点是红色
  - 情况2：叔叔节点是黑色，当前节点是右孩子
  - 情况3：叔叔节点是黑色，当前节点是左孩子

#### 13.4节 删除操作
- **标准删除**: 先按二叉搜索树删除，再修复红黑性质
- **删除修复**: 处理四种情况以维护红黑树性质
  - 情况1：兄弟节点是红色
  - 情况2：兄弟节点是黑色，兄弟的两个孩子都是黑色
  - 情况3：兄弟节点是黑色，兄弟的左孩子是红色，右孩子是黑色
  - 情况4：兄弟节点是黑色，兄弟的右孩子是红色

#### 实现特性
- **NIL节点处理**: 统一的叶子节点表示
- **颜色属性维护**: 严格的颜色约束检查
- **平衡性保证**: 最坏情况下O(log n)的操作复杂度
- **完整验证**: 红黑树五条性质的自动验证

### 第14章 区间树

#### 14.3节 区间树
- **扩展红黑树**: 基于红黑树的区间数据结构扩展
- **区间表示**: 每个节点存储一个区间 [low, high]
- **附加信息**: 每个节点维护max值（子树中所有区间的最大端点）

#### 核心操作
- **区间插入**: 按low值排序插入，维护红黑性质和max值
- **区间删除**: 删除指定区间，保持树平衡
- **区间搜索**: 查找与给定区间重叠的区间
- **精确搜索**: 查找完全匹配的区间

#### 搜索算法
- **重叠判断**: 两个区间重叠的条件：`low1 ≤ high2` 且 `low2 ≤ high1`
- **高效搜索**: 利用max值进行剪枝，时间复杂度O(log n)
- **搜索策略**:
  - 如果左子树存在且左子树的max ≥ 查询区间的low，搜索左子树
  - 否则搜索右子树

#### 实现特性
- **继承红黑树**: 基于已实现的红黑树进行扩展
- **max值维护**: 在旋转和插入删除操作中自动更新max值
- **区间验证**: 验证区间树性质的正确性
- **模板支持**: 支持任意可比较的区间端点类型

### 第15章 动态规划

#### 15.1节 钢条切割
- **问题描述**: 给定一段长度为n的钢条和一个价格表，求切割钢条方案使得销售收益最大
- **价格表表示**: `p[i]`表示长度为i的钢条的价格
- **最优子结构**: 问题具有最优子结构性质，适合用动态规划求解

#### 算法实现
- **自顶向下递归解法**: 带备忘录的递归方法，避免重复计算
- **自底向上动态规划**: 迭代解法，填充DP表
- **扩展版本**: 返回最大收益和具体的切割方案

#### 核心递推关系
```
r_n = max(p_i + r_{n-i}) for i = 1 to n
```
其中`r_n`表示长度为n的钢条的最大收益

#### 实现特性
- **多种解法**: 提供递归和迭代两种实现方式
- **切割方案重构**: 能够返回具体的切割长度序列
- **边界处理**: 正确处理长度超出价格表的情况
- **验证功能**: 自动验证切割方案的正确性

#### 15.4节 最长公共子序列
- **问题描述**: 给定两个序列X和Y，求它们的最长公共子序列（LCS）
- **动态规划解法**: 使用二维DP表存储子问题解
- **递推关系**:
  ```
  如果 X[i] = Y[j]: dp[i][j] = dp[i-1][j-1] + 1
  否则: dp[i][j] = max(dp[i-1][j], dp[i][j-1])
  ```

#### 核心功能
- **LCS长度计算**: 计算两个序列的最长公共子序列长度
- **LCS字符串重构**: 返回具体的LCS字符串
- **DP表可视化**: 打印动态规划表和方向表用于调试
- **方向追踪**: 使用方向表记录最优解路径

#### 算法实现
- **自底向上动态规划**: 迭代填充DP表
- **方向表维护**: 记录每个状态的最优选择方向
- **LCS重构算法**: 从方向表反向追踪得到LCS字符串

#### 实现特性
- **完整验证**: 自动验证LCS字符串的正确性
- **边界处理**: 正确处理空序列和单字符序列
- **可视化支持**: 提供DP表和方向表的打印功能
- **多种测试**: 包含经典示例、边界情况和正确性验证

#### 15.5节 最优二叉搜索树
- **问题描述**: 给定一组键值和对应的搜索概率，构建期望搜索成本最小的二叉搜索树
- **动态规划解法**: 使用二维DP表存储子问题的最优解
- **递推关系**:
  ```
  e[i][j] = min(e[i][r-1] + e[r+1][j] + w[i][j]) for r = i to j
  w[i][j] = w[i][j-1] + p[j]
  ```

#### 核心功能
- **最优BST构建**: 基于动态规划算法构建最优二叉搜索树
- **期望成本计算**: 计算最优BST的期望搜索成本
- **DP表可视化**: 打印期望成本表、概率和表和根表
- **树结构展示**: 可视化最优BST的层次结构

#### 算法实现
- **动态规划表**: 维护e[i][j]（期望成本）、w[i][j]（概率和）、root[i][j]（根索引）
- **最优子树构建**: 递归构建最优子树结构
- **概率权重计算**: 考虑所有键值的搜索概率
- **基于现有BST**: 扩展自第12章的二叉搜索树实现

#### 实现特性
- **继承现有BST**: 基于已实现的二叉搜索树进行扩展
- **完整验证**: 自动验证期望成本和树结构的正确性
- **多种概率模式**: 支持均匀概率、集中概率等不同模式
- **对比分析**: 提供与普通BST的性能对比

### 第18章 B树

#### 18.1节 B树的定义
- **B树定义**: 一种平衡的多路搜索树，用于磁盘存储系统
- **B树性质**:
  - 每个节点最多包含2t-1个键值
  - 每个非根节点至少包含t-1个键值
  - 每个节点最多有2t个子节点
  - 所有叶子节点位于同一深度
  - 键值按升序排列

#### 18.2节 B树的基本操作
- **搜索操作**: 从根节点开始，递归搜索合适的子树
- **插入操作**: 先搜索插入位置，必要时分裂节点
- **删除操作**: 处理三种删除情况，必要时合并或借用键值

#### 核心操作
- **节点分裂**: 当节点满时，将中间键值提升到父节点
- **节点合并**: 当节点键值过少时，与兄弟节点合并
- **键值借用**: 从兄弟节点借用键值以保持平衡
- **前驱/后继查找**: 用于内部节点删除操作

#### 算法实现
- **B树节点类**: `BTreeNode` - 包含键值向量和子节点向量
- **B树类**: `BTree` - 管理根节点和最小度数t
- **插入算法**: 递归插入，必要时分裂根节点
- **删除算法**: 处理叶子节点和内部节点的不同情况
- **搜索算法**: 递归搜索，时间复杂度O(log n)

#### 实现特性
- **模板支持**: 支持任意可比较数据类型
- **智能指针**: 使用`std::shared_ptr`管理内存
- **完整验证**: 自动验证B树五条性质
- **调试支持**: 提供树结构打印功能
- **性能优化**: 最小化磁盘I/O操作（模拟）

#### 18.3节 删除操作
- **情况1**: 删除叶子节点中的键值
- **情况2**: 删除内部节点中的键值
  - 情况2a: 前驱子节点有足够键值
  - 情况2b: 后继子节点有足够键值
  - 情况2c: 合并子节点
- **情况3**: 键值不在当前节点中，递归删除

### 第32章 字符串匹配

#### 32.1节 朴素字符串匹配算法
- **算法思想**: 检查文本中所有可能的起始位置，看模式是否匹配
- **时间复杂度**: O((n-m+1)m)，其中n是文本长度，m是模式长度
- **空间复杂度**: O(1)
- **适用场景**: 模式较短，文本不长的情况

#### 核心实现
- **滑动窗口**: 从文本的每个位置开始，检查长度为m的窗口
- **字符比较**: 逐个比较窗口内字符与模式字符
- **匹配记录**: 记录所有匹配的起始位置

#### 算法特性
- **简单直观**: 最容易理解和实现的字符串匹配算法
- **最坏情况**: 当模式频繁出现在文本中时性能较差
- **无预处理**: 不需要对模式进行预处理

#### 32.2节 Rabin-Karp算法
- **算法思想**: 使用哈希技术，将模式哈希与文本子串哈希比较
- **时间复杂度**: 平均O(n+m)，最坏O((n-m+1)m)
- **空间复杂度**: O(1)
- **适用场景**: 需要处理多个模式或模式较长的场景

#### 核心实现
- **滚动哈希**: 使用模运算实现高效的哈希值更新
- **素数选择**: 选择大素数减少哈希冲突
- **哈希验证**: 哈希匹配后进行实际字符比较

#### 算法特性
- **哈希加速**: 利用哈希值快速排除不匹配的位置
- **多模式支持**: 可以同时搜索多个模式
- **伪命中**: 可能存在哈希冲突导致的伪匹配

#### 32.3节 利用有限自动机进行字符串匹配
- **算法思想**: 构建模式对应的有限自动机，在文本上运行自动机
- **时间复杂度**: O(n)，预处理时间O(m|Σ|)
- **空间复杂度**: O(m|Σ|)，其中|Σ|是字母表大小
- **适用场景**: 需要多次使用同一模式的场景

#### 核心实现
- **状态转移表**: 构建模式的状态转移函数
- **后缀函数**: 计算模式前缀的最长真后缀
- **自动机运行**: 在文本字符序列上运行自动机

#### 算法特性
- **线性时间**: 匹配阶段达到最优时间复杂度
- **预处理开销**: 构建自动机需要额外时间和空间
- **字母表依赖**: 性能受字母表大小影响

#### 32.4节 Knuth-Morris-Pratt算法
- **算法思想**: 利用模式的前缀函数避免不必要的比较
- **时间复杂度**: O(n+m)，预处理时间O(m)
- **空间复杂度**: O(m)
- **适用场景**: 通用字符串匹配，特别是模式有重复结构

#### 核心实现
- **前缀函数**: 计算模式每个前缀的最长相等真前缀和真后缀
- **部分匹配表**: 存储前缀函数值用于跳过比较
- **智能回溯**: 利用前缀函数信息避免重复比较

#### 算法特性
- **最优复杂度**: 达到理论最优的时间复杂度
- **空间高效**: 只需要O(m)的额外空间
- **实际高效**: 在实践中通常表现优秀

#### 实现特性
- **完整实现**: 四种经典字符串匹配算法
- **模板支持**: 支持std::string和字符数组
- **性能比较**: 提供算法性能对比功能
- **调试支持**: 显示算法执行过程
- **边界处理**: 完善的错误和边界情况处理

### 第22章 图算法

#### 22.1节 图的表示
- **问题描述**: 图的两种主要表示方法 - 邻接表和邻接矩阵
- **邻接表表示**: 为每个节点维护一个链表，存储其所有邻居
- **邻接矩阵表示**: 使用二维数组表示节点之间的连接关系

#### 核心功能
- **邻接表实现**: 支持无向图和有向图的邻接表表示
- **邻接矩阵实现**: 支持无向图和有向图的邻接矩阵表示
- **图遍历算法**: 广度优先搜索（BFS）和深度优先搜索（DFS）
- **图操作**: 添加节点、添加边、查询邻居、计算度等

#### 算法实现
- **邻接表类**: `AdjacencyListGraph` - 使用链表存储邻居关系
- **邻接矩阵类**: `AdjacencyMatrixGraph` - 使用二维数组存储连接关系
- **图节点和边**: 定义`GraphNode`和`GraphEdge`结构
- **遍历算法**: 基于队列的BFS和基于栈的DFS

#### 实现特性
- **两种表示方法**: 完整实现邻接表和邻接矩阵
- **错误处理**: 完善的异常处理机制
- **性能对比**: 分析两种表示方法的空间和时间复杂度
- **经典示例**: 实现算法导论中的经典图示例
- **完整验证**: 验证两种表示方法的一致性

#### 22.4节 拓扑排序
- **问题描述**: 对有向无环图（DAG）进行线性排序，使得对于每条有向边(u, v)，u在排序中都出现在v之前
- **算法导论方法**: 使用深度优先搜索（DFS）进行拓扑排序
- **替代算法**: 基于入度的Kahn算法

#### 核心功能
- **DFS拓扑排序**: 基于深度优先搜索的拓扑排序算法
- **Kahn拓扑排序**: 基于入度计算的拓扑排序算法
- **环检测**: 自动检测图中是否存在环
- **DAG验证**: 验证图是否为有向无环图

#### 算法实现
- **DFS算法**: 使用DFS遍历图，在节点完成访问时将其加入结果栈
- **Kahn算法**: 基于入度计算，不断移除入度为0的节点
- **环检测机制**: 在DFS过程中检测后向边来判断是否存在环
- **拓扑排序验证**: 验证排序结果是否满足所有边的方向约束

#### 实现特性
- **两种算法**: 完整实现DFS和Kahn两种拓扑排序算法
- **环检测**: 自动检测并报告图中的环
- **经典示例**: 实现算法导论中的穿衣顺序和课程依赖示例
- **完整验证**: 验证拓扑排序结果的正确性
- **性能分析**: 两种算法的时间复杂度均为O(V + E)

### 第23章 最小生成树

#### 23.1节 最小生成树的形成
- **问题描述**: 在连通无向图中找到连接所有节点的最小权重边集合
- **最小生成树性质**: 包含所有节点且总权重最小的树结构
- **应用场景**: 网络设计、电路布线、聚类分析等

#### 23.2节 Kruskal算法和Prim算法
- **Kruskal算法**: 基于边排序和并查集的贪心算法
- **Prim算法**: 基于节点扩展和优先队列的贪心算法
- **算法正确性**: 两种算法都基于贪心选择性质，保证得到最小生成树

#### 核心功能
- **Kruskal算法实现**: 按权重排序边，使用并查集避免环
- **Prim算法实现**: 从起始节点扩展，使用优先队列选择最小权重边
- **MST验证**: 验证生成树是否包含所有节点且无环
- **权重计算**: 计算最小生成树的总权重

#### 算法实现
- **并查集数据结构**: 支持Kruskal算法的集合操作
- **优先队列**: 支持Prim算法的边选择
- **边权重管理**: 完整的权重计算和比较机制
- **图连通性检查**: 确保图是连通的

#### 实现特性
- **两种经典算法**: 完整实现Kruskal和Prim算法
- **并查集优化**: 路径压缩和按秩合并
- **性能分析**: Kruskal O(E log E), Prim O(E log V)
- **经典示例**: 实现算法导论图23.1的经典示例
- **完整验证**: 自动验证最小生成树的正确性
- **错误处理**: 处理有向图、空图等边界情况

### 第24章 单源最短路径

#### 24.1节 Bellman-Ford算法
- **问题描述**: 在一般有向图中（允许负权边）找到从源点到所有其他节点的最短路径
- **算法思想**: 通过|V|-1次松弛操作，逐步逼近最短路径
- **负权环检测**: 额外检查是否存在负权环
- **时间复杂度**: O(VE)，其中V是节点数，E是边数

#### 核心功能
- **松弛操作**: 对每条边进行松弛，更新最短距离估计
- **负权环检测**: 检查是否存在可以无限降低路径权重的环
- **路径重构**: 记录前驱节点，重构最短路径
- **边界处理**: 处理不可达节点和负权环情况

#### 算法实现
- **距离向量**: 存储从源点到每个节点的最短距离估计
- **前驱向量**: 记录最短路径上的前驱节点
- **边遍历**: 对所有边进行|V|-1次松弛操作
- **环检测**: 额外遍历检查是否存在负权环

#### 实现特性
- **通用性**: 支持有向图，允许负权边
- **安全性**: 自动检测负权环并报告
- **完整性**: 返回距离向量、前驱向量和环检测结果
- **经典示例**: 实现算法导论图24.4的经典示例

#### 24.2节 有向无环图中的单源最短路径问题
- **问题描述**: 在有向无环图（DAG）中高效计算单源最短路径
- **算法思想**: 先进行拓扑排序，然后按照拓扑顺序处理节点
- **时间复杂度**: O(V + E)，比Bellman-Ford更高效
- **适用场景**: 图是无环有向图的情况

#### 核心功能
- **拓扑排序**: 对DAG进行线性排序
- **顺序处理**: 按照拓扑顺序松弛出边
- **路径计算**: 计算从源点到所有节点的最短路径
- **DAG验证**: 确保输入图是有向无环图

#### 算法实现
- **拓扑排序算法**: 基于DFS或入度的拓扑排序
- **顺序松弛**: 按照拓扑顺序处理每个节点的出边
- **距离更新**: 在拓扑顺序下保证正确性
- **路径记录**: 记录最短路径的前驱节点

#### 实现特性
- **高效性**: 利用DAG特性达到线性时间复杂度
- **正确性保证**: 拓扑顺序确保松弛操作的顺序正确
- **完整性**: 支持负权边（在DAG中允许）
- **经典示例**: 实现算法导论图24.5的经典示例

#### 24.3节 Dijkstra算法
- **问题描述**: 在非负权有向图中找到从源点到所有其他节点的最短路径
- **算法思想**: 贪心算法，每次选择距离最小的未处理节点
- **数据结构**: 使用优先队列（最小堆）高效选择节点
- **时间复杂度**: O((V + E) log V)，使用二叉堆

#### 核心功能
- **贪心选择**: 每次选择当前距离最小的节点
- **松弛操作**: 更新邻居节点的距离估计
- **优先队列**: 使用最小堆维护未处理节点
- **非负权验证**: 确保图中没有负权边

#### 算法实现
- **距离向量**: 存储从源点到每个节点的最短距离
- **优先队列**: 维护未处理节点的最小距离
- **松弛策略**: 对选定节点的所有出边进行松弛
- **路径记录**: 记录最短路径的前驱节点

#### 实现特性
- **高效性**: 在非负权图中达到最优性能
- **贪心正确性**: 基于非负权假设的贪心选择正确
- **完整性**: 返回所有节点的最短距离和路径
- **经典示例**: 实现算法导论图24.6的经典示例

#### 24.4节 差分约束和最短路径
- **问题描述**: 将差分约束系统转化为最短路径问题求解
- **算法思想**: 构建约束图，使用最短路径算法求解
- **约束转化**: 将x_u - x_v ≤ w转化为边v→u权重w
- **应用场景**: 任务调度、资源分配等约束满足问题

#### 核心功能
- **约束图构建**: 将差分约束转化为有向图
- **虚拟源点**: 添加虚拟源点连接所有节点
- **Bellman-Ford求解**: 使用Bellman-Ford算法求解
- **解的存在性**: 检测约束系统是否有解

#### 算法实现
- **约束解析**: 解析差分约束不等式
- **图构建**: 构建对应的约束图
- **最短路径求解**: 应用Bellman-Ford算法
- **解验证**: 验证解是否满足所有约束

#### 实现特性
- **问题转化**: 将约束满足问题转化为图论问题
- **通用求解**: 支持任意线性不等式约束
- **无解检测**: 自动检测约束系统是否无解
- **实际应用**: 展示最短路径算法的实际应用

#### 24.5节 最短路径性质的证明
- **最优子结构**: 最短路径的任何子路径也是最短路径
- **三角不等式**: 对于任意边(u,v)，有δ(s,v) ≤ δ(s,u) + w(u,v)
- **上界性质**: 距离估计是实际距离的上界
- **收敛性质**: 在无负权环的图中，算法最终收敛

#### 实现特性
- **性质验证**: 自动验证最短路径的各种性质
- **正确性保证**: 基于严格数学证明的算法实现
- **边界情况**: 处理各种边界情况和特殊输入
- **性能分析**: 分析不同算法的时间空间复杂度

## 构建和运行

### 环境要求
- CMake 3.10+
- 支持C++17的编译器（GCC 7+, Clang 5+, MSVC 2017+）

### 构建项目
```bash
# 使用构建脚本（推荐）
./build.sh

# 或者手动构建
mkdir build && cd build
cmake ..
make -j$(nproc)
```

### 运行演示程序
```bash
# 堆演示
./build/bin/heap_demo

# 优先队列演示
./build/bin/priority_queue_demo

# 栈和队列演示
./build/bin/stack_queue_demo

# 链表演示
./build/bin/linked_list_demo

# 有根树演示
./build/bin/rooted_tree_demo

# 二叉搜索树演示
./build/bin/binary_search_tree_demo

# 红黑树演示
./build/bin/red_black_tree_demo

# 区间树演示
./build/bin/interval_tree_demo

# 钢条切割演示
./build/bin/rod_cutting_demo

# 最长公共子序列演示
./build/bin/longest_common_subsequence_demo

# 最优二叉搜索树演示
./build/bin/optimal_binary_search_tree_demo

# 图的表示演示
./build/bin/graph_representation_demo

# 拓扑排序演示
./build/bin/topological_sort_demo

# 最小生成树演示
./build/bin/minimum_spanning_tree_demo

# 单源最短路径演示
./build/bin/shortest_path_demo

# 所有节点对最短路径演示
./build/bin/all_pairs_shortest_path_demo

# B树演示
./build/bin/b_tree_demo

# 字符串匹配演示
./build/bin/string_matching_demo

# 散列表演示
./build/bin/hash_table_demo

# 最大流演示
./build/bin/max_flow_demo
```
