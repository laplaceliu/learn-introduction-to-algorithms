# 算法导论学习项目

这是一个基于CMake的C++项目，用于学习和实现《算法导论》中的经典算法和数据结构。

## 项目特点

- **模块化设计**: 每个算法/数据结构都有独立的实现和演示程序
- **标准实现**: 严格按照《算法导论》的算法描述和操作规范实现
- **完整测试**: 每个实现都包含详细的演示程序和边界情况测试
- **现代C++**: 使用C++17标准，包含智能指针、模板等现代特性

## 目录结构

```
learn-introduction-to-algorithms/
├── CMakeLists.txt          # CMake配置文件
├── build.sh                # 构建脚本
├── README.md               # 项目说明文档
├── include/                 # 扁平结构头文件目录
│   ├── heap.h              # 6.1节堆数据结构
│   ├── priority_queue.h    # 6.4节优先队列
│   ├── stack_queue.h       # 10.1节栈和队列
│   ├── linked_list.h       # 10.2节链表
│   ├── rooted_tree.h       # 10.4节有根树
│   ├── binary_search_tree.h # 12章二叉搜索树
│   ├── red_black_tree.h    # 13章红黑树
│   ├── interval_tree.h     # 14章区间树
│   ├── rod_cutting.h      # 15章钢条切割
│   ├── longest_common_subsequence.h # 15.4章最长公共子序列
│   └── optimal_binary_search_tree.h # 15.5章最优二叉搜索树
└── source/                 # 章节结构源文件目录
    ├── chapter6/
    │   ├── heap_demo.cpp              # 6.1节堆演示程序
    │   └── priority_queue_demo.cpp    # 6.4节优先队列演示程序
    ├── chapter10/
    │   ├── stack_queue_demo.cpp       # 10.1节栈和队列演示程序
    │   ├── linked_list_demo.cpp       # 10.2节链表演示程序
    │   └── rooted_tree_demo.cpp       # 10.4节有根树演示程序
    ├── chapter12/
    │   └── binary_search_tree_demo.cpp # 12章二叉搜索树演示程序
    ├── chapter13/
    │   └── red_black_tree_demo.cpp    # 13章红黑树演示程序
    ├── chapter14/
    │   └── interval_tree_demo.cpp     # 14章区间树演示程序
    └── chapter15/
        ├── rod_cutting_demo.cpp       # 15章钢条切割演示程序
        ├── longest_common_subsequence_demo.cpp # 15.4章最长公共子序列演示程序
        └── optimal_binary_search_tree_demo.cpp # 15.5章最优二叉搜索树演示程序
```

## 已实现内容

### 第6章 堆排序

#### 6.1节 堆
- **最大堆实现**: 基于数组的最大堆数据结构
- **核心操作**:
  - `max_heapify`: 维护堆性质
  - `build_max_heap`: 构建最大堆
  - 堆排序算法
- **功能特性**:
  - 插入元素（上浮操作）
  - 提取最大值
  - 堆排序
  - 完整的错误处理

#### 6.4节 优先队列
- **基本优先队列**: 基于最大堆的优先队列
- **增强版优先队列**: 支持INCREASE-KEY操作
- **标准操作**:
  - `INSERT(S, x)`: 插入元素
  - `MAXIMUM(S)`: 返回最大元素
  - `EXTRACT-MAX(S)`: 提取并删除最大元素
  - `INCREASE-KEY(S, x, k)`: 增加元素的关键字

### 第10章 基本数据结构

#### 10.1节 栈和队列
- **栈实现**: 基于数组的栈数据结构
  - `PUSH(S, x)`: 压入元素
  - `POP(S)`: 弹出元素
  - `STACK-EMPTY(S)`: 检查栈是否为空
- **队列实现**: 基于循环数组的队列
  - `ENQUEUE(Q, x)`: 入队
  - `DEQUEUE(Q)`: 出队
  - `QUEUE-EMPTY(Q)`: 检查队列是否为空
- **扩展实现**:
  - 双端队列（Deque）
  - 用两个栈实现队列（练习10.1-6）

#### 10.2节 链表
- **单向链表**: 支持标准链表操作
  - `LIST-SEARCH(L, k)`: 搜索包含关键字k的元素
  - `LIST-INSERT(L, x)`: 在链表前端插入元素
  - `LIST-DELETE(L, x)`: 删除元素x
- **双向链表**: 支持双向遍历和操作
- **循环链表**: 尾节点指向头节点的循环结构

#### 10.4节 有根树的表示
- **通用有根树**: 支持任意分支的有根树结构
  - 节点包含父指针和子节点向量
  - 深度和高度计算
  - 叶子节点判断
- **遍历算法**:
  - 前序遍历
  - 后序遍历
  - 层序遍历（广度优先）
- **搜索算法**:
  - 广度优先搜索（BFS）
  - 深度优先搜索（DFS）
- **二叉树特例**: 作为有根树的特例实现
  - 左子树和右子树支持
  - 中序遍历、前序遍历、后序遍历

### 第12章 二叉搜索树

#### 12.1节 二叉搜索树
- **标准实现**: 基于指针的二叉搜索树数据结构
- **核心操作**:
  - `INSERT(T, z)`: 插入节点
  - `DELETE(T, z)`: 删除节点
  - `SEARCH(T, k)`: 查找包含关键字k的节点
- **查询操作**:
  - `MINIMUM(x)`: 查找以x为根的子树的最小节点
  - `MAXIMUM(x)`: 查找以x为根的子树的最大节点
  - `SUCCESSOR(x)`: 查找节点x的后继
  - `PREDECESSOR(x)`: 查找节点x的前驱
- **遍历算法**:
  - 中序遍历（按关键字升序）
  - 前序遍历
  - 后序遍历
  - 层序遍历
- **高级特性**:
  - 树高度计算
  - 二叉搜索树性质验证
  - 移植操作（TRANSPLANT）
  - 支持任意可比较数据类型

### 第13章 红黑树

#### 13.1节 红黑树性质
- **红黑树定义**: 满足以下性质的二叉搜索树：
  - 每个节点是红色或黑色
  - 根节点是黑色
  - 每个叶子节点（NIL）是黑色
  - 红色节点的两个子节点都是黑色
  - 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

#### 13.2节 旋转操作
- **左旋操作**: 保持二叉搜索树性质的局部调整
- **右旋操作**: 左旋的对称操作
- **旋转复杂度**: O(1)时间完成

#### 13.3节 插入操作
- **标准插入**: 先按二叉搜索树插入，再修复红黑性质
- **插入修复**: 处理三种情况以维护红黑树性质
  - 情况1：叔叔节点是红色
  - 情况2：叔叔节点是黑色，当前节点是右孩子
  - 情况3：叔叔节点是黑色，当前节点是左孩子

#### 13.4节 删除操作
- **标准删除**: 先按二叉搜索树删除，再修复红黑性质
- **删除修复**: 处理四种情况以维护红黑树性质
  - 情况1：兄弟节点是红色
  - 情况2：兄弟节点是黑色，兄弟的两个孩子都是黑色
  - 情况3：兄弟节点是黑色，兄弟的左孩子是红色，右孩子是黑色
  - 情况4：兄弟节点是黑色，兄弟的右孩子是红色

#### 实现特性
- **NIL节点处理**: 统一的叶子节点表示
- **颜色属性维护**: 严格的颜色约束检查
- **平衡性保证**: 最坏情况下O(log n)的操作复杂度
- **完整验证**: 红黑树五条性质的自动验证

### 第14章 区间树

#### 14.3节 区间树
- **扩展红黑树**: 基于红黑树的区间数据结构扩展
- **区间表示**: 每个节点存储一个区间 [low, high]
- **附加信息**: 每个节点维护max值（子树中所有区间的最大端点）

#### 核心操作
- **区间插入**: 按low值排序插入，维护红黑性质和max值
- **区间删除**: 删除指定区间，保持树平衡
- **区间搜索**: 查找与给定区间重叠的区间
- **精确搜索**: 查找完全匹配的区间

#### 搜索算法
- **重叠判断**: 两个区间重叠的条件：`low1 ≤ high2` 且 `low2 ≤ high1`
- **高效搜索**: 利用max值进行剪枝，时间复杂度O(log n)
- **搜索策略**: 
  - 如果左子树存在且左子树的max ≥ 查询区间的low，搜索左子树
  - 否则搜索右子树

#### 实现特性
- **继承红黑树**: 基于已实现的红黑树进行扩展
- **max值维护**: 在旋转和插入删除操作中自动更新max值
- **区间验证**: 验证区间树性质的正确性
- **模板支持**: 支持任意可比较的区间端点类型

### 第15章 动态规划

#### 15.1节 钢条切割
- **问题描述**: 给定一段长度为n的钢条和一个价格表，求切割钢条方案使得销售收益最大
- **价格表表示**: `p[i]`表示长度为i的钢条的价格
- **最优子结构**: 问题具有最优子结构性质，适合用动态规划求解

#### 算法实现
- **自顶向下递归解法**: 带备忘录的递归方法，避免重复计算
- **自底向上动态规划**: 迭代解法，填充DP表
- **扩展版本**: 返回最大收益和具体的切割方案

#### 核心递推关系
```
r_n = max(p_i + r_{n-i}) for i = 1 to n
```
其中`r_n`表示长度为n的钢条的最大收益

#### 实现特性
- **多种解法**: 提供递归和迭代两种实现方式
- **切割方案重构**: 能够返回具体的切割长度序列
- **边界处理**: 正确处理长度超出价格表的情况
- **验证功能**: 自动验证切割方案的正确性

### 第15.4章 最长公共子序列

#### 15.4节 最长公共子序列
- **问题描述**: 给定两个序列X和Y，求它们的最长公共子序列（LCS）
- **动态规划解法**: 使用二维DP表存储子问题解
- **递推关系**: 
  ```
  如果 X[i] = Y[j]: dp[i][j] = dp[i-1][j-1] + 1
  否则: dp[i][j] = max(dp[i-1][j], dp[i][j-1])
  ```

#### 核心功能
- **LCS长度计算**: 计算两个序列的最长公共子序列长度
- **LCS字符串重构**: 返回具体的LCS字符串
- **DP表可视化**: 打印动态规划表和方向表用于调试
- **方向追踪**: 使用方向表记录最优解路径

#### 算法实现
- **自底向上动态规划**: 迭代填充DP表
- **方向表维护**: 记录每个状态的最优选择方向
- **LCS重构算法**: 从方向表反向追踪得到LCS字符串

#### 实现特性
- **完整验证**: 自动验证LCS字符串的正确性
- **边界处理**: 正确处理空序列和单字符序列
- **可视化支持**: 提供DP表和方向表的打印功能
- **多种测试**: 包含经典示例、边界情况和正确性验证

### 第15.5章 最优二叉搜索树

#### 15.5节 最优二叉搜索树
- **问题描述**: 给定一组键值和对应的搜索概率，构建期望搜索成本最小的二叉搜索树
- **动态规划解法**: 使用二维DP表存储子问题的最优解
- **递推关系**: 
  ```
  e[i][j] = min(e[i][r-1] + e[r+1][j] + w[i][j]) for r = i to j
  w[i][j] = w[i][j-1] + p[j]
  ```

#### 核心功能
- **最优BST构建**: 基于动态规划算法构建最优二叉搜索树
- **期望成本计算**: 计算最优BST的期望搜索成本
- **DP表可视化**: 打印期望成本表、概率和表和根表
- **树结构展示**: 可视化最优BST的层次结构

#### 算法实现
- **动态规划表**: 维护e[i][j]（期望成本）、w[i][j]（概率和）、root[i][j]（根索引）
- **最优子树构建**: 递归构建最优子树结构
- **概率权重计算**: 考虑所有键值的搜索概率
- **基于现有BST**: 扩展自第12章的二叉搜索树实现

#### 实现特性
- **继承现有BST**: 基于已实现的二叉搜索树进行扩展
- **完整验证**: 自动验证期望成本和树结构的正确性
- **多种概率模式**: 支持均匀概率、集中概率等不同模式
- **对比分析**: 提供与普通BST的性能对比

## 构建和运行

### 环境要求
- CMake 3.10+
- 支持C++17的编译器（GCC 7+, Clang 5+, MSVC 2017+）

### 构建项目
```bash
# 使用构建脚本（推荐）
./build.sh

# 或者手动构建
mkdir build && cd build
cmake ..
make -j$(nproc)
```

### 运行演示程序
```bash
# 堆演示
./build/bin/heap_demo

# 优先队列演示
./build/bin/priority_queue_demo

# 栈和队列演示
./build/bin/stack_queue_demo

# 链表演示
./build/bin/linked_list_demo

# 有根树演示
./build/bin/rooted_tree_demo

# 二叉搜索树演示
./build/bin/binary_search_tree_demo

# 红黑树演示
./build/bin/red_black_tree_demo

# 区间树演示
./build/bin/interval_tree_demo

# 钢条切割演示
./build/bin/rod_cutting_demo

# 最长公共子序列演示
./build/bin/longest_common_subsequence_demo

# 最优二叉搜索树演示
./build/bin/optimal_binary_search_tree_demo
```
